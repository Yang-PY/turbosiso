<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>SISO: SISO_dem.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.9 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
<h1>SISO_dem.cpp</h1><a href="SISO__dem_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 
<a name="l00006"></a>00006 <span class="preprocessor">#include "<a class="code" href="SISO_8h.html" title="Soft Input Soft Output (SISO) modules class header.">SISO.h</a>"</span>
<a name="l00007"></a>00007 
<a name="l00008"></a>00008 <span class="keyword">namespace </span>tr
<a name="l00009"></a>00009 {
<a name="l00010"></a><a class="code" href="classtr_1_1SISO.html#548106d8da90413e8ce9b43755ab0fa8">00010</a> <span class="keywordtype">void</span> <a class="code" href="classtr_1_1SISO.html#548106d8da90413e8ce9b43755ab0fa8" title="Finds half constellations.">SISO::find_half_const</a>(<span class="keywordtype">int</span> &amp;select_half, itpp::vec &amp;re_part, itpp::bmat &amp;re_bin_part, itpp::vec &amp;im_part, itpp::bmat &amp;im_bin_part)
<a name="l00011"></a>00011 <span class="comment">/* finds real in imaginary parts of the constellation and its corresponding bits</span>
<a name="l00012"></a>00012 <span class="comment"> * this approach is used for equivalent channel according to Hassibi's model </span>
<a name="l00013"></a>00013 <span class="comment"> * the constellation must be quadratic and the number of bits per symbol must be a multiple of two</span>
<a name="l00014"></a>00014 <span class="comment"> */</span>
<a name="l00015"></a>00015 {
<a name="l00016"></a>00016     <span class="comment">//values needed for initializations</span>
<a name="l00017"></a>00017     <span class="keywordtype">int</span> const_size = itpp::pow2i(<a class="code" href="classtr_1_1SISO.html#6b1847842f0ec2a1f2760a1859d84bfc" title="Number of bits/symbol.">nb_bits_symb</a>);<span class="comment">//constellation size</span>
<a name="l00018"></a>00018     <span class="keywordtype">int</span> half_nb_bits_symb = <a class="code" href="classtr_1_1SISO.html#6b1847842f0ec2a1f2760a1859d84bfc" title="Number of bits/symbol.">nb_bits_symb</a>/2;
<a name="l00019"></a>00019     <span class="keywordtype">int</span> half_len = itpp::pow2i(half_nb_bits_symb);<span class="comment">//number of values of real(imaginary) part    </span>
<a name="l00020"></a>00020     <span class="comment">//initialize output variables</span>
<a name="l00021"></a>00021     select_half = 0;
<a name="l00022"></a>00022     re_part.set_size(half_len);    
<a name="l00023"></a>00023     re_bin_part.set_size(half_len, half_nb_bits_symb);
<a name="l00024"></a>00024     re_part.zeros();
<a name="l00025"></a>00025     re_part(0) = <a class="code" href="classtr_1_1SISO.html#66228208aac18d4a2642de5a95ee52ff" title="Complex constellation.">constellation</a>(0).real();    
<a name="l00026"></a>00026     im_part.set_size(half_len);        
<a name="l00027"></a>00027     im_bin_part.set_size(half_len, half_nb_bits_symb);
<a name="l00028"></a>00028     im_part.zeros();
<a name="l00029"></a>00029     im_part(0) = <a class="code" href="classtr_1_1SISO.html#66228208aac18d4a2642de5a95ee52ff" title="Complex constellation.">constellation</a>(0).imag();    
<a name="l00030"></a>00030     <span class="comment">//select half for real (imaginary) to binary correspondence</span>
<a name="l00031"></a>00031     <span class="keywordflow">if</span> (<a class="code" href="classtr_1_1SISO.html#6b1847842f0ec2a1f2760a1859d84bfc" title="Number of bits/symbol.">nb_bits_symb</a>%2)
<a name="l00032"></a>00032     {
<a name="l00033"></a>00033         <a class="code" href="classtr_1_1SISO.html#6f005953de144f4f877d8cbce35254a3" title="Prints an error message to standard output.">print_err_msg</a>(<span class="stringliteral">"SISO::find_half_const: number of bits per symbol must be a multiple of two"</span>);
<a name="l00034"></a>00034         <span class="keywordflow">return</span>;
<a name="l00035"></a>00035     }
<a name="l00036"></a>00036     <span class="keyword">const</span> <span class="keywordtype">double</span> min_diff = 1e-3;
<a name="l00037"></a>00037     itpp::ivec idx = itpp::find(itpp::abs(itpp::real(<a class="code" href="classtr_1_1SISO.html#66228208aac18d4a2642de5a95ee52ff" title="Complex constellation.">constellation</a>)-re_part(0))&lt;min_diff);
<a name="l00038"></a>00038     <span class="keywordflow">if</span> (idx.length()!=half_len)
<a name="l00039"></a>00039     {
<a name="l00040"></a>00040         <a class="code" href="classtr_1_1SISO.html#6f005953de144f4f877d8cbce35254a3" title="Prints an error message to standard output.">print_err_msg</a>(<span class="stringliteral">"SISO::find_half_const: the constellation must be quadratic"</span>);
<a name="l00041"></a>00041         <span class="keywordflow">return</span>;
<a name="l00042"></a>00042     }
<a name="l00043"></a>00043     itpp::bvec <a class="code" href="sccc_8m.html#f78ef0e37e7fb8bc7e29d55d92ad055f">temp</a>(<a class="code" href="classtr_1_1SISO.html#6b1847842f0ec2a1f2760a1859d84bfc" title="Number of bits/symbol.">nb_bits_symb</a>);
<a name="l00044"></a>00044     <span class="keyword">register</span> <span class="keywordtype">int</span> <a class="code" href="pccc_8m.html#b16835ef8374501899a0b3db115584fc">n</a>;
<a name="l00045"></a>00045     <span class="keywordflow">for</span> (n=0;n&lt;2;n++)
<a name="l00046"></a>00046     {
<a name="l00047"></a>00047         temp = <a class="code" href="classtr_1_1SISO.html#8af248fca5002121beca5a4a5673ba12" title="Binary constellation.">bin_constellation</a>.get_row(idx(n));        
<a name="l00048"></a>00048         re_bin_part.set_row(n,<a class="code" href="sccc_8m.html#f78ef0e37e7fb8bc7e29d55d92ad055f">temp</a>(0,half_nb_bits_symb-1));
<a name="l00049"></a>00049     }
<a name="l00050"></a>00050     select_half = (re_bin_part.get_row(0)==re_bin_part.get_row(1))?0:1;
<a name="l00051"></a>00051     <span class="comment">//algorithm    </span>
<a name="l00052"></a>00052     <span class="keywordtype">double</span> buffer;
<a name="l00053"></a>00053     temp = <a class="code" href="classtr_1_1SISO.html#8af248fca5002121beca5a4a5673ba12" title="Binary constellation.">bin_constellation</a>.get_row(0);
<a name="l00054"></a>00054     re_bin_part.set_row(0,<a class="code" href="sccc_8m.html#f78ef0e37e7fb8bc7e29d55d92ad055f">temp</a>(select_half*half_nb_bits_symb,(1+select_half)*half_nb_bits_symb-1));
<a name="l00055"></a>00055     im_bin_part.set_row(0,<a class="code" href="sccc_8m.html#f78ef0e37e7fb8bc7e29d55d92ad055f">temp</a>((1-select_half)*half_nb_bits_symb,(2-select_half)*half_nb_bits_symb-1));   
<a name="l00056"></a>00056     <span class="keywordtype">int</span> re_idx = 0;
<a name="l00057"></a>00057     <span class="keywordtype">int</span> im_idx = 0;
<a name="l00058"></a>00058     <span class="keywordflow">for</span> (n=1;n&lt;const_size;n++)
<a name="l00059"></a>00059     {
<a name="l00060"></a>00060         temp = <a class="code" href="classtr_1_1SISO.html#8af248fca5002121beca5a4a5673ba12" title="Binary constellation.">bin_constellation</a>.get_row(n);
<a name="l00061"></a>00061         buffer = <a class="code" href="classtr_1_1SISO.html#66228208aac18d4a2642de5a95ee52ff" title="Complex constellation.">constellation</a>(n).real();
<a name="l00062"></a>00062         <span class="keywordflow">if</span> (itpp::prod(re_part-buffer)&gt;min_diff)
<a name="l00063"></a>00063         {
<a name="l00064"></a>00064             re_idx++;
<a name="l00065"></a>00065             re_part(re_idx) = buffer;
<a name="l00066"></a>00066             re_bin_part.set_row(re_idx, <a class="code" href="sccc_8m.html#f78ef0e37e7fb8bc7e29d55d92ad055f">temp</a>(select_half*half_nb_bits_symb,(1+select_half)*half_nb_bits_symb-1));
<a name="l00067"></a>00067         }
<a name="l00068"></a>00068         buffer = <a class="code" href="classtr_1_1SISO.html#66228208aac18d4a2642de5a95ee52ff" title="Complex constellation.">constellation</a>(n).imag();
<a name="l00069"></a>00069         <span class="keywordflow">if</span> (itpp::prod(im_part-buffer)&gt;min_diff)
<a name="l00070"></a>00070         {
<a name="l00071"></a>00071             im_idx++;
<a name="l00072"></a>00072             im_part(im_idx) = buffer;
<a name="l00073"></a>00073             im_bin_part.set_row(im_idx, <a class="code" href="sccc_8m.html#f78ef0e37e7fb8bc7e29d55d92ad055f">temp</a>((1-select_half)*half_nb_bits_symb,(2-select_half)*half_nb_bits_symb-1));
<a name="l00074"></a>00074         }
<a name="l00075"></a>00075     }
<a name="l00076"></a>00076 }
<a name="l00077"></a>00077 
<a name="l00078"></a><a class="code" href="classtr_1_1SISO.html#71ccbd3b3b5481096cf9d7c3c16f1343">00078</a> <span class="keywordtype">void</span> <a class="code" href="classtr_1_1SISO.html#71ccbd3b3b5481096cf9d7c3c16f1343" title="Finds equivalent received signal with real coefficients.">SISO::EquivRecSig</a>(itpp::vec &amp;x_eq, <span class="keyword">const</span> itpp::cmat &amp;rec_sig)
<a name="l00079"></a>00079 <span class="comment">//finds equivalent received signal with real coefficients</span>
<a name="l00080"></a>00080 <span class="comment">//the equivalent received signal follows the model of Hassibi's paper</span>
<a name="l00081"></a>00081 <span class="comment">//ouput:</span>
<a name="l00082"></a>00082 <span class="comment">//x_eq - equivalent received signal with real coefficients</span>
<a name="l00083"></a>00083 <span class="comment">//inputs:</span>
<a name="l00084"></a>00084 <span class="comment">//rec_sig - received signal</span>
<a name="l00085"></a>00085 {
<a name="l00086"></a>00086     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0;k&lt;<a class="code" href="classtr_1_1SISO.html#8435e16f233e0d70d4335c0695a9ed78" title="Number of reception antennas.">nb_rec_ant</a>;k++)
<a name="l00087"></a>00087     {
<a name="l00088"></a>00088         x_eq.set_subvector(k*2*<a class="code" href="classtr_1_1SISO.html#5f08c69d75d1ed4d3152f5d9d1e45836" title="ST code block duration.">block_duration</a>, itpp::real(rec_sig.get_col(k)));
<a name="l00089"></a>00089         x_eq.set_subvector(k*2*block_duration+block_duration, itpp::imag(rec_sig.get_col(k)));
<a name="l00090"></a>00090     }
<a name="l00091"></a>00091 }
<a name="l00092"></a>00092 
<a name="l00093"></a><a class="code" href="classtr_1_1SISO.html#a4e6c5634642f73694b44a38eb0164a8">00093</a> <span class="keywordtype">void</span> <a class="code" href="classtr_1_1SISO.html#a4e6c5634642f73694b44a38eb0164a8" title="Finds equivalent channel with real coefficients.">SISO::EquivCh</a>(itpp::mat &amp;H_eq, <span class="keyword">const</span> itpp::cvec &amp;H)
<a name="l00094"></a>00094 <span class="comment">//finds equivalent channel with real coefficients following the model of Hassibi's paper</span>
<a name="l00095"></a>00095 <span class="comment">//output:</span>
<a name="l00096"></a>00096 <span class="comment">//H_eq - equivalent channel</span>
<a name="l00097"></a>00097 <span class="comment">//input:</span>
<a name="l00098"></a>00098 <span class="comment">//H - channel matrix</span>
<a name="l00099"></a>00099 {
<a name="l00100"></a>00100     itpp::mat Aq(2*<a class="code" href="classtr_1_1SISO.html#5f08c69d75d1ed4d3152f5d9d1e45836" title="ST code block duration.">block_duration</a>,2*<a class="code" href="classtr_1_1SISO.html#38f94774848f716b03774b8087aab581" title="Number of emission antennas.">nb_em_ant</a>);
<a name="l00101"></a>00101     itpp::mat Bq(2*<a class="code" href="classtr_1_1SISO.html#5f08c69d75d1ed4d3152f5d9d1e45836" title="ST code block duration.">block_duration</a>,2*<a class="code" href="classtr_1_1SISO.html#38f94774848f716b03774b8087aab581" title="Number of emission antennas.">nb_em_ant</a>);
<a name="l00102"></a>00102     itpp::cmat <a class="code" href="sccc_8m.html#f78ef0e37e7fb8bc7e29d55d92ad055f">temp</a>(<a class="code" href="classtr_1_1SISO.html#5f08c69d75d1ed4d3152f5d9d1e45836" title="ST code block duration.">block_duration</a>,<a class="code" href="classtr_1_1SISO.html#38f94774848f716b03774b8087aab581" title="Number of emission antennas.">nb_em_ant</a>);
<a name="l00103"></a>00103     itpp::vec h(2*<a class="code" href="classtr_1_1SISO.html#38f94774848f716b03774b8087aab581" title="Number of emission antennas.">nb_em_ant</a>);
<a name="l00104"></a>00104     itpp::mat AhBh(2*<a class="code" href="classtr_1_1SISO.html#5f08c69d75d1ed4d3152f5d9d1e45836" title="ST code block duration.">block_duration</a>,2);
<a name="l00105"></a>00105     <span class="keyword">register</span> <span class="keywordtype">int</span> <a class="code" href="pccc_8m.html#b16835ef8374501899a0b3db115584fc">n</a>,k;
<a name="l00106"></a>00106     <span class="keywordflow">for</span> (k=0;k&lt;<a class="code" href="classtr_1_1SISO.html#6f3b090b54b8bf8bda6114ee2d679b3b" title="Number of symbols/block.">symbols_block</a>;k++)
<a name="l00107"></a>00107     {
<a name="l00108"></a>00108         temp = <a class="code" href="classtr_1_1SISO.html#fa973ffb52c1e230b41ea333d184fd1f" title="ST generator matrix 1.">ST_gen1</a>.get(k*<a class="code" href="classtr_1_1SISO.html#5f08c69d75d1ed4d3152f5d9d1e45836" title="ST code block duration.">block_duration</a>,k*block_duration+block_duration-1,0,<a class="code" href="classtr_1_1SISO.html#38f94774848f716b03774b8087aab581" title="Number of emission antennas.">nb_em_ant</a>-1);
<a name="l00109"></a>00109         Aq.set_submatrix(0, 0, itpp::real(temp));
<a name="l00110"></a>00110         Aq.set_submatrix(0, <a class="code" href="classtr_1_1SISO.html#38f94774848f716b03774b8087aab581" title="Number of emission antennas.">nb_em_ant</a>, -itpp::imag(temp));
<a name="l00111"></a>00111         Aq.set_submatrix(block_duration, 0, itpp::imag(temp));
<a name="l00112"></a>00112         Aq.set_submatrix(block_duration, <a class="code" href="classtr_1_1SISO.html#38f94774848f716b03774b8087aab581" title="Number of emission antennas.">nb_em_ant</a>, itpp::real(temp));
<a name="l00113"></a>00113         temp = <a class="code" href="classtr_1_1SISO.html#3dbe8127714523e06c4071aa8b95feb8" title="ST generator matrix 2.">ST_gen2</a>.get(k*block_duration,k*block_duration+block_duration-1,0,<a class="code" href="classtr_1_1SISO.html#38f94774848f716b03774b8087aab581" title="Number of emission antennas.">nb_em_ant</a>-1);
<a name="l00114"></a>00114         Bq.set_submatrix(0, 0, -itpp::imag(temp));
<a name="l00115"></a>00115         Bq.set_submatrix(0, <a class="code" href="classtr_1_1SISO.html#38f94774848f716b03774b8087aab581" title="Number of emission antennas.">nb_em_ant</a>, -itpp::real(temp));
<a name="l00116"></a>00116         Bq.set_submatrix(block_duration, 0, itpp::real(temp));
<a name="l00117"></a>00117         Bq.set_submatrix(block_duration, <a class="code" href="classtr_1_1SISO.html#38f94774848f716b03774b8087aab581" title="Number of emission antennas.">nb_em_ant</a>, -itpp::imag(temp));
<a name="l00118"></a>00118         <span class="keywordflow">for</span> (n=0;n&lt;<a class="code" href="classtr_1_1SISO.html#8435e16f233e0d70d4335c0695a9ed78" title="Number of reception antennas.">nb_rec_ant</a>;n++)
<a name="l00119"></a>00119         {
<a name="l00120"></a>00120             h.set_subvector(0, real(H.mid(n*<a class="code" href="classtr_1_1SISO.html#38f94774848f716b03774b8087aab581" title="Number of emission antennas.">nb_em_ant</a>,nb_em_ant)));
<a name="l00121"></a>00121             h.set_subvector(nb_em_ant, imag(H.mid(n*nb_em_ant,nb_em_ant)));
<a name="l00122"></a>00122             AhBh.set_col(0, Aq*h);
<a name="l00123"></a>00123             AhBh.set_col(1, Bq*h);
<a name="l00124"></a>00124             H_eq.set_submatrix(2*block_duration*n, 2*k, AhBh);
<a name="l00125"></a>00125         }
<a name="l00126"></a>00126     }
<a name="l00127"></a>00127 }
<a name="l00128"></a>00128 
<a name="l00129"></a><a class="code" href="classtr_1_1SISO.html#1537fce51c16bc998f2ecf5ec365cab0">00129</a> <span class="keywordtype">void</span> <a class="code" href="classtr_1_1SISO.html#1537fce51c16bc998f2ecf5ec365cab0" title="SISO::demapper using maxlogMAP algorithm for ST block codes described using Hassibi&amp;#39;s...">SISO::Hassibi_maxlogMAP</a>(itpp::vec &amp;<a class="code" href="pccc_8m.html#5281907479deebb2221449a1a435e6f9">extrinsic_data</a>, <span class="keyword">const</span> itpp::cmat &amp;rec_sig, <span class="keyword">const</span> itpp::vec &amp;<a class="code" href="pccc_8m.html#538daf4079e02293176bdde2a829700f">apriori_data</a>)
<a name="l00130"></a>00130 <span class="comment">//maxlogMAP algorithm for ST block codes using Hassibi's model</span>
<a name="l00131"></a>00131 {
<a name="l00132"></a>00132     <span class="comment">//general parameters</span>
<a name="l00133"></a>00133     <span class="keywordtype">int</span> nb_subblocks = rec_sig.rows()/<a class="code" href="classtr_1_1SISO.html#5f08c69d75d1ed4d3152f5d9d1e45836" title="ST code block duration.">block_duration</a>;<span class="comment">//number of subblocks of ST matrices/int period</span>
<a name="l00134"></a>00134     <span class="keywordtype">double</span> N0 = 2*<a class="code" href="classtr_1_1SISO.html#0ad35ce8bb26a5d25f5cc56470cf70c4" title="AWGN noise variance.">sigma2</a>;<span class="comment">//noise DSP</span>
<a name="l00135"></a>00135     <span class="keywordtype">int</span> nb_all_symb = itpp::pow2i(<a class="code" href="classtr_1_1SISO.html#6b1847842f0ec2a1f2760a1859d84bfc" title="Number of bits/symbol.">nb_bits_symb</a>*<a class="code" href="classtr_1_1SISO.html#6f3b090b54b8bf8bda6114ee2d679b3b" title="Number of symbols/block.">symbols_block</a>);<span class="comment">//nb. of all possible input symbols as a binary vector</span>
<a name="l00136"></a>00136     <span class="keywordtype">double</span> nom,denom;<span class="comment">//nominator and denominator of extrinsic information</span>
<a name="l00137"></a>00137     itpp::bvec bin_frame(<a class="code" href="classtr_1_1SISO.html#6b1847842f0ec2a1f2760a1859d84bfc" title="Number of bits/symbol.">nb_bits_symb</a>*symbols_block);<span class="comment">//binary frame at channel input</span>
<a name="l00138"></a>00138     itpp::bmat mat_bin_frame(<a class="code" href="classtr_1_1SISO.html#6b1847842f0ec2a1f2760a1859d84bfc" title="Number of bits/symbol.">nb_bits_symb</a>, symbols_block);
<a name="l00139"></a>00139     itpp::vec symb_frame_eq(2*symbols_block);<span class="comment">//frame of symbols at equivalent channel input</span>
<a name="l00140"></a>00140     <span class="keywordtype">double</span> <a class="code" href="sccc_8m.html#f78ef0e37e7fb8bc7e29d55d92ad055f">temp</a>;
<a name="l00141"></a>00141     itpp::mat H_eq(2*<a class="code" href="classtr_1_1SISO.html#8435e16f233e0d70d4335c0695a9ed78" title="Number of reception antennas.">nb_rec_ant</a>*<a class="code" href="classtr_1_1SISO.html#5f08c69d75d1ed4d3152f5d9d1e45836" title="ST code block duration.">block_duration</a>,2*symbols_block);<span class="comment">//equivalent channel matrix</span>
<a name="l00142"></a>00142     itpp::vec x_eq(2*block_duration*<a class="code" href="classtr_1_1SISO.html#8435e16f233e0d70d4335c0695a9ed78" title="Number of reception antennas.">nb_rec_ant</a>);<span class="comment">//equivalent received signal</span>
<a name="l00143"></a>00143     <span class="keyword">register</span> <span class="keywordtype">int</span> ns,q,nb,<a class="code" href="pccc_8m.html#b16835ef8374501899a0b3db115584fc">n</a>,k;
<a name="l00144"></a>00144     <span class="keywordtype">int</span> index;
<a name="l00145"></a>00145     extrinsic_data.set_size(<a class="code" href="classtr_1_1SISO.html#6b1847842f0ec2a1f2760a1859d84bfc" title="Number of bits/symbol.">nb_bits_symb</a>*nb_subblocks*symbols_block);
<a name="l00146"></a>00146     <span class="comment">//main loop</span>
<a name="l00147"></a>00147     <span class="keywordflow">for</span> (ns=0;ns&lt;nb_subblocks;ns++)<span class="comment">//for each subblock</span>
<a name="l00148"></a>00148     {
<a name="l00149"></a>00149         <span class="comment">//find equivalent channel matrix</span>
<a name="l00150"></a>00150         <a class="code" href="classtr_1_1SISO.html#a4e6c5634642f73694b44a38eb0164a8" title="Finds equivalent channel with real coefficients.">EquivCh</a>(H_eq, <a class="code" href="classtr_1_1SISO.html#dc1f0c3c2ac4579b91b6c859207c1812" title="Complex channel impulse response.">c_impulse_response</a>.get_col(ns));
<a name="l00151"></a>00151         <span class="comment">//find equivalent received signal</span>
<a name="l00152"></a>00152         <a class="code" href="classtr_1_1SISO.html#71ccbd3b3b5481096cf9d7c3c16f1343" title="Finds equivalent received signal with real coefficients.">EquivRecSig</a>(x_eq, rec_sig(ns*block_duration,(ns+1)*block_duration-1,0,nb_rec_ant-1));
<a name="l00153"></a>00153         <span class="comment">//compute the LLR of each bit in a frame of symbols_block symbols</span>
<a name="l00154"></a>00154         <span class="keywordflow">for</span> (q=0;q&lt;symbols_block;q++)<span class="comment">//for each symbol in a subblock</span>
<a name="l00155"></a>00155         {
<a name="l00156"></a>00156             <span class="keywordflow">for</span> (nb=0;nb&lt;<a class="code" href="classtr_1_1SISO.html#6b1847842f0ec2a1f2760a1859d84bfc" title="Number of bits/symbol.">nb_bits_symb</a>;nb++)<span class="comment">//for a given bit try all possible sollutions for the input symbol vector</span>
<a name="l00157"></a>00157             {
<a name="l00158"></a>00158                 nom = -INFINITY;
<a name="l00159"></a>00159                 denom = -INFINITY;
<a name="l00160"></a>00160                 <span class="keywordflow">for</span> (n=0;n&lt;nb_all_symb;n++)<span class="comment">//all possible symbols</span>
<a name="l00161"></a>00161                 {
<a name="l00162"></a>00162                     bin_frame = itpp::dec2bin(nb_bits_symb*symbols_block, n);
<a name="l00163"></a>00163                     mat_bin_frame = itpp::reshape(bin_frame, nb_bits_symb, symbols_block);
<a name="l00164"></a>00164                     <span class="keywordflow">for</span> (k=0;k&lt;symbols_block;k++)
<a name="l00165"></a>00165                     {
<a name="l00166"></a>00166                         symb_frame_eq(2*k) = <a class="code" href="classtr_1_1SISO.html#66228208aac18d4a2642de5a95ee52ff" title="Complex constellation.">constellation</a>(itpp::bin2dec(mat_bin_frame.get_col(k))).real();
<a name="l00167"></a>00167                         symb_frame_eq(1+2*k) = <a class="code" href="classtr_1_1SISO.html#66228208aac18d4a2642de5a95ee52ff" title="Complex constellation.">constellation</a>(itpp::bin2dec(mat_bin_frame.get_col(k))).imag();
<a name="l00168"></a>00168                     }
<a name="l00169"></a>00169                     temp = -itpp::sum_sqr(x_eq-H_eq*symb_frame_eq)/N0+\
<a name="l00170"></a>00170                            itpp::to_vec(bin_frame)*apriori_data.mid(ns*nb_bits_symb*symbols_block,nb_bits_symb*symbols_block);
<a name="l00171"></a>00171                     <span class="keywordflow">if</span> (bin_frame(nb+q*nb_bits_symb))
<a name="l00172"></a>00172                         nom = std::max(nom, temp);
<a name="l00173"></a>00173                     <span class="keywordflow">else</span>
<a name="l00174"></a>00174                         denom = std::max(denom, temp);
<a name="l00175"></a>00175                 }
<a name="l00176"></a>00176                 index = nb+q*nb_bits_symb+ns*nb_bits_symb*symbols_block;
<a name="l00177"></a>00177                 <a class="code" href="pccc_8m.html#5281907479deebb2221449a1a435e6f9">extrinsic_data</a>(index) = (nom-denom)-<a class="code" href="pccc_8m.html#538daf4079e02293176bdde2a829700f">apriori_data</a>(index);
<a name="l00178"></a>00178             }<span class="comment">//bits/symbol</span>
<a name="l00179"></a>00179         }<span class="comment">//symbols/subblock</span>
<a name="l00180"></a>00180     }<span class="comment">//subblocks</span>
<a name="l00181"></a>00181 }
<a name="l00182"></a>00182 
<a name="l00183"></a><a class="code" href="classtr_1_1SISO.html#61466cc0c4226823d745fa7ef5ab2727">00183</a> <span class="keywordtype">void</span> <a class="code" href="classtr_1_1SISO.html#61466cc0c4226823d745fa7ef5ab2727" title="SISO::demapper using Gaussian Approximation (GA) algorithm.">SISO::GA</a>(itpp::vec &amp;<a class="code" href="pccc_8m.html#5281907479deebb2221449a1a435e6f9">extrinsic_data</a>, <span class="keyword">const</span> itpp::cmat &amp;rec_sig, <span class="keyword">const</span> itpp::vec &amp;<a class="code" href="pccc_8m.html#538daf4079e02293176bdde2a829700f">apriori_data</a>)
<a name="l00184"></a>00184 <span class="comment">// Gaussian Approximation algorithm for ST codes using Hassibi's model</span>
<a name="l00185"></a>00185 {
<a name="l00186"></a>00186     <span class="comment">//general parameters</span>
<a name="l00187"></a>00187     <span class="keywordtype">int</span> nb_subblocks = rec_sig.rows()/<a class="code" href="classtr_1_1SISO.html#5f08c69d75d1ed4d3152f5d9d1e45836" title="ST code block duration.">block_duration</a>;<span class="comment">//number of subblocks</span>
<a name="l00188"></a>00188     <span class="keywordtype">int</span> half_nb_bits_symb = <a class="code" href="classtr_1_1SISO.html#6b1847842f0ec2a1f2760a1859d84bfc" title="Number of bits/symbol.">nb_bits_symb</a>/2;
<a name="l00189"></a>00189     <span class="keywordtype">int</span> half_len = itpp::pow2i(half_nb_bits_symb);<span class="comment">//number of values of real(imaginary) part</span>
<a name="l00190"></a>00190 
<a name="l00191"></a>00191     <span class="comment">//correspondence between real and imaginary part of symbols and their binary representations</span>
<a name="l00192"></a>00192     <span class="keywordtype">int</span> select_half;
<a name="l00193"></a>00193     itpp::vec re_part;
<a name="l00194"></a>00194     itpp::bmat re_bin_part;
<a name="l00195"></a>00195     itpp::vec im_part;
<a name="l00196"></a>00196     itpp::bmat im_bin_part;
<a name="l00197"></a>00197     <a class="code" href="classtr_1_1SISO.html#548106d8da90413e8ce9b43755ab0fa8" title="Finds half constellations.">find_half_const</a>(select_half, re_part, re_bin_part, im_part, im_bin_part);
<a name="l00198"></a>00198 
<a name="l00199"></a>00199     <span class="comment">//equivalent channel</span>
<a name="l00200"></a>00200     itpp::mat H_eq(2*<a class="code" href="classtr_1_1SISO.html#8435e16f233e0d70d4335c0695a9ed78" title="Number of reception antennas.">nb_rec_ant</a>*<a class="code" href="classtr_1_1SISO.html#5f08c69d75d1ed4d3152f5d9d1e45836" title="ST code block duration.">block_duration</a>,2*<a class="code" href="classtr_1_1SISO.html#6f3b090b54b8bf8bda6114ee2d679b3b" title="Number of symbols/block.">symbols_block</a>);
<a name="l00201"></a>00201     itpp::vec E_re_s(<a class="code" href="classtr_1_1SISO.html#6f3b090b54b8bf8bda6114ee2d679b3b" title="Number of symbols/block.">symbols_block</a>);
<a name="l00202"></a>00202     itpp::vec E_im_s(<a class="code" href="classtr_1_1SISO.html#6f3b090b54b8bf8bda6114ee2d679b3b" title="Number of symbols/block.">symbols_block</a>);
<a name="l00203"></a>00203     itpp::vec Var_re_s(<a class="code" href="classtr_1_1SISO.html#6f3b090b54b8bf8bda6114ee2d679b3b" title="Number of symbols/block.">symbols_block</a>);
<a name="l00204"></a>00204     itpp::vec Var_im_s(<a class="code" href="classtr_1_1SISO.html#6f3b090b54b8bf8bda6114ee2d679b3b" title="Number of symbols/block.">symbols_block</a>);
<a name="l00205"></a>00205     itpp::vec Ey(2*block_duration*<a class="code" href="classtr_1_1SISO.html#8435e16f233e0d70d4335c0695a9ed78" title="Number of reception antennas.">nb_rec_ant</a>);
<a name="l00206"></a>00206     itpp::mat Cy(2*block_duration*nb_rec_ant,2*block_duration*nb_rec_ant);
<a name="l00207"></a>00207     itpp::mat Cy_inv(2*block_duration*nb_rec_ant,2*block_duration*nb_rec_ant);
<a name="l00208"></a>00208     itpp::vec x_eq(2*block_duration*nb_rec_ant);
<a name="l00209"></a>00209     itpp::vec EZeta(2*block_duration*nb_rec_ant);
<a name="l00210"></a>00210     itpp::mat CZeta_inv(2*block_duration*nb_rec_ant,2*block_duration*nb_rec_ant);
<a name="l00211"></a>00211     <span class="keywordtype">double</span> nom,denom;
<a name="l00212"></a>00212     <span class="keywordtype">double</span> <a class="code" href="sccc_8m.html#f78ef0e37e7fb8bc7e29d55d92ad055f">temp</a>;
<a name="l00213"></a>00213     <span class="keyword">register</span> <span class="keywordtype">int</span> ns,q,k,p,cs;
<a name="l00214"></a>00214     <span class="keywordtype">int</span> index;
<a name="l00215"></a>00215     extrinsic_data.set_size(<a class="code" href="classtr_1_1SISO.html#6b1847842f0ec2a1f2760a1859d84bfc" title="Number of bits/symbol.">nb_bits_symb</a>*nb_subblocks*<a class="code" href="classtr_1_1SISO.html#6f3b090b54b8bf8bda6114ee2d679b3b" title="Number of symbols/block.">symbols_block</a>);
<a name="l00216"></a>00216     <span class="keywordflow">for</span> (ns=0;ns&lt;nb_subblocks;ns++)<span class="comment">//subblock by subblock</span>
<a name="l00217"></a>00217     {
<a name="l00218"></a>00218         <span class="comment">//mean and variance of real and imaginary parts of emitted symbols</span>
<a name="l00219"></a>00219         E_re_s.zeros();
<a name="l00220"></a>00220         E_im_s.zeros();
<a name="l00221"></a>00221         Var_re_s.zeros();
<a name="l00222"></a>00222         Var_im_s.zeros();
<a name="l00223"></a>00223         <span class="keywordflow">for</span> (q=0;q&lt;symbols_block;q++)
<a name="l00224"></a>00224         {
<a name="l00225"></a>00225             index = q*<a class="code" href="classtr_1_1SISO.html#6b1847842f0ec2a1f2760a1859d84bfc" title="Number of bits/symbol.">nb_bits_symb</a>+ns*symbols_block*<a class="code" href="classtr_1_1SISO.html#6b1847842f0ec2a1f2760a1859d84bfc" title="Number of bits/symbol.">nb_bits_symb</a>;
<a name="l00226"></a>00226             <span class="keywordflow">for</span> (k=0;k&lt;half_len;k++)
<a name="l00227"></a>00227             {
<a name="l00228"></a>00228                 E_re_s(q) += re_part(k)*itpp::prod(itpp::elem_div(exp(itpp::elem_mult(itpp::to_vec(re_bin_part.get_row(k)),\
<a name="l00229"></a>00229                                                       apriori_data.mid(select_half*half_nb_bits_symb+index,half_nb_bits_symb))),\
<a name="l00230"></a>00230                                                       1+exp(apriori_data.mid(select_half*half_nb_bits_symb+index,half_nb_bits_symb))));
<a name="l00231"></a>00231                 E_im_s(q) += im_part(k)*itpp::prod(itpp::elem_div(exp(itpp::elem_mult(itpp::to_vec(im_bin_part.get_row(k)),\
<a name="l00232"></a>00232                                                       apriori_data.mid((1-select_half)*half_nb_bits_symb+index,half_nb_bits_symb))),\
<a name="l00233"></a>00233                                                       1+exp(apriori_data.mid((1-select_half)*half_nb_bits_symb+index,half_nb_bits_symb))));
<a name="l00234"></a>00234                 Var_re_s(q) += itpp::sqr(re_part(k))*itpp::prod(itpp::elem_div(exp(itpp::elem_mult(itpp::to_vec(re_bin_part.get_row(k)),\
<a name="l00235"></a>00235                                                     apriori_data.mid(select_half*half_nb_bits_symb+index,half_nb_bits_symb))),\
<a name="l00236"></a>00236                                                     1+exp(apriori_data.mid(select_half*half_nb_bits_symb+index,half_nb_bits_symb))));
<a name="l00237"></a>00237                 Var_im_s(q) += itpp::sqr(im_part(k))*itpp::prod(itpp::elem_div(exp(itpp::elem_mult(itpp::to_vec(im_bin_part.get_row(k)),\
<a name="l00238"></a>00238                                                     apriori_data.mid((1-select_half)*half_nb_bits_symb+index,half_nb_bits_symb))),\
<a name="l00239"></a>00239                                                     1+exp(apriori_data.mid((1-select_half)*half_nb_bits_symb+index,half_nb_bits_symb))));
<a name="l00240"></a>00240             }
<a name="l00241"></a>00241             Var_re_s(q) -= itpp::sqr(E_re_s(q));
<a name="l00242"></a>00242             Var_im_s(q) -= itpp::sqr(E_im_s(q));
<a name="l00243"></a>00243         }
<a name="l00244"></a>00244 
<a name="l00245"></a>00245         <span class="comment">//find equivalent channel</span>
<a name="l00246"></a>00246         <a class="code" href="classtr_1_1SISO.html#a4e6c5634642f73694b44a38eb0164a8" title="Finds equivalent channel with real coefficients.">EquivCh</a>(H_eq, <a class="code" href="classtr_1_1SISO.html#dc1f0c3c2ac4579b91b6c859207c1812" title="Complex channel impulse response.">c_impulse_response</a>.get_col(ns));
<a name="l00247"></a>00247 
<a name="l00248"></a>00248         <span class="comment">//compute E[y] and Cov[y]</span>
<a name="l00249"></a>00249         Ey.zeros();
<a name="l00250"></a>00250         Cy = <a class="code" href="classtr_1_1SISO.html#0ad35ce8bb26a5d25f5cc56470cf70c4" title="AWGN noise variance.">sigma2</a>*itpp::eye(2*block_duration*nb_rec_ant);
<a name="l00251"></a>00251         <span class="keywordflow">for</span> (q=0;q&lt;symbols_block;q++)
<a name="l00252"></a>00252         {
<a name="l00253"></a>00253             <span class="comment">//real &amp; imaginary</span>
<a name="l00254"></a>00254             Ey += (H_eq.get_col(2*q)*E_re_s(q)+H_eq.get_col(1+2*q)*E_im_s(q));
<a name="l00255"></a>00255             Cy += (itpp::outer_product(H_eq.get_col(2*q), H_eq.get_col(2*q)*Var_re_s(q))+\
<a name="l00256"></a>00256                 itpp::outer_product(H_eq.get_col(1+2*q), H_eq.get_col(1+2*q)*Var_im_s(q)));
<a name="l00257"></a>00257         }
<a name="l00258"></a>00258 
<a name="l00259"></a>00259         <span class="comment">//inverse of Cov[y]</span>
<a name="l00260"></a>00260         Cy_inv = itpp::inv(Cy);
<a name="l00261"></a>00261 
<a name="l00262"></a>00262         <span class="comment">//find equivalent received signal</span>
<a name="l00263"></a>00263         <a class="code" href="classtr_1_1SISO.html#71ccbd3b3b5481096cf9d7c3c16f1343" title="Finds equivalent received signal with real coefficients.">EquivRecSig</a>(x_eq, rec_sig(ns*block_duration,(ns+1)*block_duration-1,0,nb_rec_ant-1));
<a name="l00264"></a>00264 
<a name="l00265"></a>00265         <span class="comment">//compute extrinsic information of coded bits</span>
<a name="l00266"></a>00266         <span class="keywordflow">for</span> (q=0;q&lt;symbols_block;q++)
<a name="l00267"></a>00267         {
<a name="l00268"></a>00268             <span class="comment">//real part</span>
<a name="l00269"></a>00269             EZeta = Ey-H_eq.get_col(2*q)*E_re_s(q);
<a name="l00270"></a>00270             CZeta_inv = Cy_inv+itpp::outer_product(Cy_inv*\
<a name="l00271"></a>00271                                 ((Var_re_s(q)/(1-(((H_eq.get_col(2*q)).transpose()*Cy_inv)*(H_eq.get_col(2*q)*Var_re_s(q)))(0)))*\
<a name="l00272"></a>00272                                  H_eq.get_col(2*q)), Cy_inv.transpose()*H_eq.get_col(2*q));
<a name="l00273"></a>00273             index = select_half*half_nb_bits_symb+q*<a class="code" href="classtr_1_1SISO.html#6b1847842f0ec2a1f2760a1859d84bfc" title="Number of bits/symbol.">nb_bits_symb</a>+ns*symbols_block*<a class="code" href="classtr_1_1SISO.html#6b1847842f0ec2a1f2760a1859d84bfc" title="Number of bits/symbol.">nb_bits_symb</a>;                                          
<a name="l00274"></a>00274             <span class="keywordflow">for</span> (p=0;p&lt;half_nb_bits_symb;p++)
<a name="l00275"></a>00275             {
<a name="l00276"></a>00276                 nom = -INFINITY;
<a name="l00277"></a>00277                 denom = -INFINITY;                
<a name="l00278"></a>00278                 <span class="keywordflow">for</span> (cs=0;cs&lt;half_len;cs++)
<a name="l00279"></a>00279                 {
<a name="l00280"></a>00280                     temp = -0.5*((x_eq-H_eq.get_col(2*q)*re_part(cs)-EZeta).transpose()*CZeta_inv*(x_eq-H_eq.get_col(2*q)*re_part(cs)-EZeta))(0)+\
<a name="l00281"></a>00281                            itpp::to_vec(re_bin_part.get_row(cs))*apriori_data.mid(index,half_nb_bits_symb);
<a name="l00282"></a>00282                     <span class="keywordflow">if</span> (re_bin_part(cs,p))
<a name="l00283"></a>00283                         nom = std::max(nom, temp);
<a name="l00284"></a>00284                     <span class="keywordflow">else</span>
<a name="l00285"></a>00285                         denom = std::max(denom, temp);
<a name="l00286"></a>00286                 }
<a name="l00287"></a>00287                 <a class="code" href="pccc_8m.html#5281907479deebb2221449a1a435e6f9">extrinsic_data</a>(index+p) = (nom-denom)-<a class="code" href="pccc_8m.html#538daf4079e02293176bdde2a829700f">apriori_data</a>(index+p);
<a name="l00288"></a>00288             }
<a name="l00289"></a>00289             <span class="comment">//imaginary part</span>
<a name="l00290"></a>00290             EZeta = Ey-H_eq.get_col(1+2*q)*E_im_s(q);
<a name="l00291"></a>00291             CZeta_inv = Cy_inv+itpp::outer_product(Cy_inv*\
<a name="l00292"></a>00292                                 ((Var_im_s(q)/(1-(((H_eq.get_col(1+2*q)).transpose()*Cy_inv)*(H_eq.get_col(1+2*q)*Var_im_s(q)))(0)))*\
<a name="l00293"></a>00293                                  H_eq.get_col(1+2*q)), Cy_inv.transpose()*H_eq.get_col(1+2*q));
<a name="l00294"></a>00294             index = (1-select_half)*half_nb_bits_symb+q*nb_bits_symb+ns*symbols_block*nb_bits_symb;                                 
<a name="l00295"></a>00295             <span class="keywordflow">for</span> (p=0;p&lt;half_nb_bits_symb;p++)
<a name="l00296"></a>00296             {
<a name="l00297"></a>00297                 nom = -INFINITY;
<a name="l00298"></a>00298                 denom = -INFINITY;                
<a name="l00299"></a>00299                 <span class="keywordflow">for</span> (cs=0;cs&lt;half_len;cs++)
<a name="l00300"></a>00300                 {
<a name="l00301"></a>00301                     temp = -0.5*((x_eq-H_eq.get_col(1+2*q)*im_part(cs)-EZeta).transpose()*CZeta_inv*(x_eq-H_eq.get_col(1+2*q)*im_part(cs)-EZeta))(0)+\
<a name="l00302"></a>00302                            itpp::to_vec(im_bin_part.get_row(cs))*apriori_data.mid(index,half_nb_bits_symb);
<a name="l00303"></a>00303                     <span class="keywordflow">if</span> (im_bin_part(cs,p))
<a name="l00304"></a>00304                         nom = std::max(nom, temp);
<a name="l00305"></a>00305                     <span class="keywordflow">else</span>
<a name="l00306"></a>00306                         denom = std::max(denom, temp);
<a name="l00307"></a>00307                 }
<a name="l00308"></a>00308                 <a class="code" href="pccc_8m.html#5281907479deebb2221449a1a435e6f9">extrinsic_data</a>(index+p) = (nom-denom)-<a class="code" href="pccc_8m.html#538daf4079e02293176bdde2a829700f">apriori_data</a>(index+p);
<a name="l00309"></a>00309             }
<a name="l00310"></a>00310         }
<a name="l00311"></a>00311     }<span class="comment">//subblock by subblock</span>
<a name="l00312"></a>00312 }
<a name="l00313"></a>00313 
<a name="l00314"></a><a class="code" href="classtr_1_1SISO.html#5c8101da252f277c2e0573482c61d52b">00314</a> <span class="keywordtype">void</span> <a class="code" href="classtr_1_1SISO.html#5c8101da252f277c2e0573482c61d52b" title="SISO::demapper using simplified Gaussian Approximation (sGA) algorithm.">SISO::sGA</a>(itpp::vec &amp;<a class="code" href="pccc_8m.html#5281907479deebb2221449a1a435e6f9">extrinsic_data</a>, <span class="keyword">const</span> itpp::cmat &amp;rec_sig, <span class="keyword">const</span> itpp::vec &amp;<a class="code" href="pccc_8m.html#538daf4079e02293176bdde2a829700f">apriori_data</a>)
<a name="l00315"></a>00315 <span class="comment">//simplified Gaussian Approximation algorithm for ST codes using Hassibi's model</span>
<a name="l00316"></a>00316 {
<a name="l00317"></a>00317     <span class="comment">//general parameters</span>
<a name="l00318"></a>00318     <span class="keywordtype">int</span> nb_subblocks = (int)(rec_sig.rows()/<a class="code" href="classtr_1_1SISO.html#5f08c69d75d1ed4d3152f5d9d1e45836" title="ST code block duration.">block_duration</a>);<span class="comment">//number of subblocks</span>
<a name="l00319"></a>00319     <span class="keywordtype">int</span> half_nb_bits_symb = (int)(<a class="code" href="classtr_1_1SISO.html#6b1847842f0ec2a1f2760a1859d84bfc" title="Number of bits/symbol.">nb_bits_symb</a>/2);
<a name="l00320"></a>00320     <span class="keywordtype">int</span> half_len = itpp::pow2i(half_nb_bits_symb);<span class="comment">//number of values of real(imaginary) part</span>
<a name="l00321"></a>00321 
<a name="l00322"></a>00322     <span class="comment">//correspondence between real and imaginary part of symbols and their binary representations</span>
<a name="l00323"></a>00323     <span class="keywordtype">int</span> select_half;
<a name="l00324"></a>00324     itpp::vec re_part;
<a name="l00325"></a>00325     itpp::bmat re_bin_part;
<a name="l00326"></a>00326     itpp::vec im_part;
<a name="l00327"></a>00327     itpp::bmat im_bin_part;
<a name="l00328"></a>00328     <a class="code" href="classtr_1_1SISO.html#548106d8da90413e8ce9b43755ab0fa8" title="Finds half constellations.">find_half_const</a>(select_half, re_part, re_bin_part, im_part, im_bin_part);
<a name="l00329"></a>00329 
<a name="l00330"></a>00330     <span class="comment">//equivalent channel</span>
<a name="l00331"></a>00331     itpp::mat H_eq(2*<a class="code" href="classtr_1_1SISO.html#8435e16f233e0d70d4335c0695a9ed78" title="Number of reception antennas.">nb_rec_ant</a>*<a class="code" href="classtr_1_1SISO.html#5f08c69d75d1ed4d3152f5d9d1e45836" title="ST code block duration.">block_duration</a>,2*<a class="code" href="classtr_1_1SISO.html#6f3b090b54b8bf8bda6114ee2d679b3b" title="Number of symbols/block.">symbols_block</a>);
<a name="l00332"></a>00332 
<a name="l00333"></a>00333     itpp::vec E_re_s(<a class="code" href="classtr_1_1SISO.html#6f3b090b54b8bf8bda6114ee2d679b3b" title="Number of symbols/block.">symbols_block</a>);
<a name="l00334"></a>00334     itpp::vec E_im_s(<a class="code" href="classtr_1_1SISO.html#6f3b090b54b8bf8bda6114ee2d679b3b" title="Number of symbols/block.">symbols_block</a>);
<a name="l00335"></a>00335     itpp::vec Var_re_s(<a class="code" href="classtr_1_1SISO.html#6f3b090b54b8bf8bda6114ee2d679b3b" title="Number of symbols/block.">symbols_block</a>);
<a name="l00336"></a>00336     itpp::vec Var_im_s(<a class="code" href="classtr_1_1SISO.html#6f3b090b54b8bf8bda6114ee2d679b3b" title="Number of symbols/block.">symbols_block</a>);
<a name="l00337"></a>00337     itpp::vec Ey(2*block_duration*<a class="code" href="classtr_1_1SISO.html#8435e16f233e0d70d4335c0695a9ed78" title="Number of reception antennas.">nb_rec_ant</a>);
<a name="l00338"></a>00338     itpp::mat Cy(2*block_duration*nb_rec_ant,2*block_duration*nb_rec_ant);
<a name="l00339"></a>00339     itpp::vec x_eq(2*block_duration*nb_rec_ant);
<a name="l00340"></a>00340     itpp::vec EZeta(2*block_duration*nb_rec_ant);
<a name="l00341"></a>00341     itpp::vec CZeta(2*block_duration*nb_rec_ant);
<a name="l00342"></a>00342     <span class="keywordtype">double</span> nom,denom;
<a name="l00343"></a>00343     <span class="keywordtype">double</span> <a class="code" href="sccc_8m.html#f78ef0e37e7fb8bc7e29d55d92ad055f">temp</a>;
<a name="l00344"></a>00344     <span class="keyword">register</span> <span class="keywordtype">int</span> ns,q,k,p,cs;
<a name="l00345"></a>00345     <span class="keywordtype">int</span> index;
<a name="l00346"></a>00346     extrinsic_data.set_size(<a class="code" href="classtr_1_1SISO.html#6b1847842f0ec2a1f2760a1859d84bfc" title="Number of bits/symbol.">nb_bits_symb</a>*nb_subblocks*<a class="code" href="classtr_1_1SISO.html#6f3b090b54b8bf8bda6114ee2d679b3b" title="Number of symbols/block.">symbols_block</a>);
<a name="l00347"></a>00347     <span class="keywordflow">for</span> (ns=0;ns&lt;nb_subblocks;ns++)<span class="comment">//subblock by subblock</span>
<a name="l00348"></a>00348     {
<a name="l00349"></a>00349         <span class="comment">//mean and variance of real and imaginary parts of emitted symbols</span>
<a name="l00350"></a>00350         E_re_s.zeros();
<a name="l00351"></a>00351         E_im_s.zeros();
<a name="l00352"></a>00352         Var_re_s.zeros();
<a name="l00353"></a>00353         Var_im_s.zeros();
<a name="l00354"></a>00354         <span class="keywordflow">for</span> (q=0;q&lt;symbols_block;q++)
<a name="l00355"></a>00355         {
<a name="l00356"></a>00356             index = q*<a class="code" href="classtr_1_1SISO.html#6b1847842f0ec2a1f2760a1859d84bfc" title="Number of bits/symbol.">nb_bits_symb</a>+ns*symbols_block*<a class="code" href="classtr_1_1SISO.html#6b1847842f0ec2a1f2760a1859d84bfc" title="Number of bits/symbol.">nb_bits_symb</a>;
<a name="l00357"></a>00357             <span class="keywordflow">for</span> (k=0;k&lt;half_len;k++)
<a name="l00358"></a>00358             {
<a name="l00359"></a>00359                 E_re_s(q) += re_part(k)*itpp::prod(itpp::elem_div(exp(itpp::elem_mult(itpp::to_vec(re_bin_part.get_row(k)),\
<a name="l00360"></a>00360                                                       apriori_data.mid(select_half*half_nb_bits_symb+index,half_nb_bits_symb))),\
<a name="l00361"></a>00361                                                       1+exp(apriori_data.mid(select_half*half_nb_bits_symb+index,half_nb_bits_symb))));
<a name="l00362"></a>00362                 E_im_s(q) += im_part(k)*itpp::prod(itpp::elem_div(exp(itpp::elem_mult(itpp::to_vec(im_bin_part.get_row(k)),\
<a name="l00363"></a>00363                                                       apriori_data.mid((1-select_half)*half_nb_bits_symb+index,half_nb_bits_symb))),\
<a name="l00364"></a>00364                                                       1+exp(apriori_data.mid((1-select_half)*half_nb_bits_symb+index,half_nb_bits_symb))));
<a name="l00365"></a>00365                 Var_re_s(q) += itpp::sqr(re_part(k))*itpp::prod(itpp::elem_div(exp(itpp::elem_mult(itpp::to_vec(re_bin_part.get_row(k)),\
<a name="l00366"></a>00366                                                     apriori_data.mid(select_half*half_nb_bits_symb+index,half_nb_bits_symb))),\
<a name="l00367"></a>00367                                                     1+exp(apriori_data.mid(select_half*half_nb_bits_symb+index,half_nb_bits_symb))));
<a name="l00368"></a>00368                 Var_im_s(q) += itpp::sqr(im_part(k))*itpp::prod(itpp::elem_div(exp(itpp::elem_mult(itpp::to_vec(im_bin_part.get_row(k)),\
<a name="l00369"></a>00369                                                     apriori_data.mid((1-select_half)*half_nb_bits_symb+index,half_nb_bits_symb))),\
<a name="l00370"></a>00370                                                     1+exp(apriori_data.mid((1-select_half)*half_nb_bits_symb+index,half_nb_bits_symb))));
<a name="l00371"></a>00371             }
<a name="l00372"></a>00372             Var_re_s(q) -= itpp::sqr(E_re_s(q));
<a name="l00373"></a>00373             Var_im_s(q) -= itpp::sqr(E_im_s(q));
<a name="l00374"></a>00374         }
<a name="l00375"></a>00375 
<a name="l00376"></a>00376         <span class="comment">//find equivalent channel</span>
<a name="l00377"></a>00377         <a class="code" href="classtr_1_1SISO.html#a4e6c5634642f73694b44a38eb0164a8" title="Finds equivalent channel with real coefficients.">EquivCh</a>(H_eq, <a class="code" href="classtr_1_1SISO.html#dc1f0c3c2ac4579b91b6c859207c1812" title="Complex channel impulse response.">c_impulse_response</a>.get_col(ns));
<a name="l00378"></a>00378 
<a name="l00379"></a>00379         <span class="comment">//compute E[y] and Cov[y]</span>
<a name="l00380"></a>00380         Ey.zeros();
<a name="l00381"></a>00381         Cy = <a class="code" href="classtr_1_1SISO.html#0ad35ce8bb26a5d25f5cc56470cf70c4" title="AWGN noise variance.">sigma2</a>*itpp::eye(2*block_duration*nb_rec_ant);
<a name="l00382"></a>00382         <span class="keywordflow">for</span> (q=0;q&lt;symbols_block;q++)
<a name="l00383"></a>00383         {
<a name="l00384"></a>00384             <span class="comment">//real &amp; imaginary</span>
<a name="l00385"></a>00385             Ey += (H_eq.get_col(2*q)*E_re_s(q)+H_eq.get_col(1+2*q)*E_im_s(q));
<a name="l00386"></a>00386             Cy += (itpp::outer_product(H_eq.get_col(2*q), H_eq.get_col(2*q)*Var_re_s(q))+\
<a name="l00387"></a>00387                  itpp::outer_product(H_eq.get_col(1+2*q), H_eq.get_col(1+2*q)*Var_im_s(q)));
<a name="l00388"></a>00388         }
<a name="l00389"></a>00389 
<a name="l00390"></a>00390         <span class="comment">//find equivalent received signal</span>
<a name="l00391"></a>00391         <a class="code" href="classtr_1_1SISO.html#71ccbd3b3b5481096cf9d7c3c16f1343" title="Finds equivalent received signal with real coefficients.">EquivRecSig</a>(x_eq, rec_sig(ns*block_duration,(ns+1)*block_duration-1,0,nb_rec_ant-1));
<a name="l00392"></a>00392 
<a name="l00393"></a>00393         <span class="comment">//compute extrinsic INFINITYormation of coded bits</span>
<a name="l00394"></a>00394         <span class="keywordflow">for</span> (q=0;q&lt;symbols_block;q++)
<a name="l00395"></a>00395         {
<a name="l00396"></a>00396             <span class="comment">//real part</span>
<a name="l00397"></a>00397             EZeta = Ey-H_eq.get_col(2*q)*E_re_s(q);
<a name="l00398"></a>00398             CZeta = diag(Cy-itpp::outer_product(H_eq.get_col(2*q), H_eq.get_col(2*q)*Var_re_s(q)));
<a name="l00399"></a>00399             index = select_half*half_nb_bits_symb+q*<a class="code" href="classtr_1_1SISO.html#6b1847842f0ec2a1f2760a1859d84bfc" title="Number of bits/symbol.">nb_bits_symb</a>+ns*symbols_block*<a class="code" href="classtr_1_1SISO.html#6b1847842f0ec2a1f2760a1859d84bfc" title="Number of bits/symbol.">nb_bits_symb</a>;
<a name="l00400"></a>00400             <span class="keywordflow">for</span> (p=0;p&lt;half_nb_bits_symb;p++)
<a name="l00401"></a>00401             {
<a name="l00402"></a>00402                 nom = -INFINITY;
<a name="l00403"></a>00403                 denom = -INFINITY;
<a name="l00404"></a>00404                 <span class="keywordflow">for</span> (cs=0;cs&lt;half_len;cs++)
<a name="l00405"></a>00405                 {
<a name="l00406"></a>00406                     temp = -0.5*itpp::sum(itpp::elem_div(sqr(x_eq-H_eq.get_col(2*q)*re_part(cs)-EZeta), CZeta))+\
<a name="l00407"></a>00407                            itpp::to_vec(re_bin_part.get_row(cs))*apriori_data.mid(index,half_nb_bits_symb);
<a name="l00408"></a>00408                     <span class="keywordflow">if</span> (re_bin_part(cs,p))
<a name="l00409"></a>00409                         nom = std::max(nom, temp);
<a name="l00410"></a>00410                     <span class="keywordflow">else</span>
<a name="l00411"></a>00411                         denom = std::max(denom, temp);
<a name="l00412"></a>00412                 }
<a name="l00413"></a>00413                 <a class="code" href="pccc_8m.html#5281907479deebb2221449a1a435e6f9">extrinsic_data</a>(index+p) = (nom-denom)-<a class="code" href="pccc_8m.html#538daf4079e02293176bdde2a829700f">apriori_data</a>(index+p);
<a name="l00414"></a>00414             }
<a name="l00415"></a>00415             <span class="comment">//imaginary part</span>
<a name="l00416"></a>00416             EZeta = Ey-H_eq.get_col(1+2*q)*E_im_s(q);
<a name="l00417"></a>00417             CZeta = itpp::diag(Cy-itpp::outer_product(H_eq.get_col(1+2*q), H_eq.get_col(1+2*q)*Var_im_s(q)));
<a name="l00418"></a>00418             index = (1-select_half)*half_nb_bits_symb+q*nb_bits_symb+ns*symbols_block*nb_bits_symb;
<a name="l00419"></a>00419             <span class="keywordflow">for</span> (p=0;p&lt;half_nb_bits_symb;p++)
<a name="l00420"></a>00420             {
<a name="l00421"></a>00421                 nom = -INFINITY;
<a name="l00422"></a>00422                 denom = -INFINITY;
<a name="l00423"></a>00423                 <span class="keywordflow">for</span> (cs=0;cs&lt;half_len;cs++)
<a name="l00424"></a>00424                 {
<a name="l00425"></a>00425                     temp = -0.5*itpp::sum(itpp::elem_div(sqr(x_eq-H_eq.get_col(1+2*q)*im_part(cs)-EZeta), CZeta))+\
<a name="l00426"></a>00426                            itpp::to_vec(im_bin_part.get_row(cs))*apriori_data.mid(index,half_nb_bits_symb);
<a name="l00427"></a>00427                     <span class="keywordflow">if</span> (im_bin_part(cs,p))
<a name="l00428"></a>00428                         nom = std::max(nom, temp);
<a name="l00429"></a>00429                     <span class="keywordflow">else</span>
<a name="l00430"></a>00430                         denom = std::max(denom, temp);
<a name="l00431"></a>00431                 }
<a name="l00432"></a>00432                 <a class="code" href="pccc_8m.html#5281907479deebb2221449a1a435e6f9">extrinsic_data</a>(index+p) = (nom-denom)-<a class="code" href="pccc_8m.html#538daf4079e02293176bdde2a829700f">apriori_data</a>(index+p);
<a name="l00433"></a>00433             }
<a name="l00434"></a>00434         }
<a name="l00435"></a>00435     }<span class="comment">//subblock by subblock</span>
<a name="l00436"></a>00436 }
<a name="l00437"></a>00437 
<a name="l00438"></a><a class="code" href="classtr_1_1SISO.html#94c158c3c0a71a14baf686fdde1f93f9">00438</a> <span class="keywordtype">void</span> <a class="code" href="classtr_1_1SISO.html#94c158c3c0a71a14baf686fdde1f93f9" title="SISO::demapper using MMSE Parallel Interference Canceller (PIC).">SISO::mmsePIC</a>(itpp::vec &amp;<a class="code" href="pccc_8m.html#5281907479deebb2221449a1a435e6f9">extrinsic_data</a>, <span class="keyword">const</span> itpp::cmat &amp;rec_sig, <span class="keyword">const</span> itpp::vec &amp;<a class="code" href="pccc_8m.html#538daf4079e02293176bdde2a829700f">apriori_data</a>)
<a name="l00439"></a>00439 <span class="comment">//MMSE Parallel Interference Canceller</span>
<a name="l00440"></a>00440 {
<a name="l00441"></a>00441     <span class="comment">//general parameters</span>
<a name="l00442"></a>00442     <span class="keywordtype">int</span> nb_subblocks = rec_sig.rows()/<a class="code" href="classtr_1_1SISO.html#5f08c69d75d1ed4d3152f5d9d1e45836" title="ST code block duration.">block_duration</a>;<span class="comment">//number of subblocks</span>
<a name="l00443"></a>00443     <span class="keywordtype">int</span> half_nb_bits_symb = <a class="code" href="classtr_1_1SISO.html#6b1847842f0ec2a1f2760a1859d84bfc" title="Number of bits/symbol.">nb_bits_symb</a>/2;
<a name="l00444"></a>00444     <span class="keywordtype">int</span> half_const_len = itpp::pow2i(half_nb_bits_symb);
<a name="l00445"></a>00445     <span class="keywordtype">int</span> nb_bits_subblock = <a class="code" href="classtr_1_1SISO.html#6b1847842f0ec2a1f2760a1859d84bfc" title="Number of bits/symbol.">nb_bits_symb</a>*<a class="code" href="classtr_1_1SISO.html#6f3b090b54b8bf8bda6114ee2d679b3b" title="Number of symbols/block.">symbols_block</a>;<span class="comment">//number of coded bits in an ST block</span>
<a name="l00446"></a>00446     itpp::vec <a class="code" href="BICM_8m.html#84b7e4f5537f440cbbf66ab569334e32">Es</a>(2*symbols_block);
<a name="l00447"></a>00447     itpp::vec Vs(2*symbols_block);
<a name="l00448"></a>00448     itpp::mat H_eq(2*<a class="code" href="classtr_1_1SISO.html#8435e16f233e0d70d4335c0695a9ed78" title="Number of reception antennas.">nb_rec_ant</a>*<a class="code" href="classtr_1_1SISO.html#5f08c69d75d1ed4d3152f5d9d1e45836" title="ST code block duration.">block_duration</a>,2*symbols_block);
<a name="l00449"></a>00449     itpp::mat K(2*<a class="code" href="classtr_1_1SISO.html#8435e16f233e0d70d4335c0695a9ed78" title="Number of reception antennas.">nb_rec_ant</a>*block_duration,2*<a class="code" href="classtr_1_1SISO.html#8435e16f233e0d70d4335c0695a9ed78" title="Number of reception antennas.">nb_rec_ant</a>*block_duration);
<a name="l00450"></a>00450     itpp::mat K_inv(2*<a class="code" href="classtr_1_1SISO.html#8435e16f233e0d70d4335c0695a9ed78" title="Number of reception antennas.">nb_rec_ant</a>*block_duration,2*<a class="code" href="classtr_1_1SISO.html#8435e16f233e0d70d4335c0695a9ed78" title="Number of reception antennas.">nb_rec_ant</a>*block_duration);
<a name="l00451"></a>00451     itpp::vec x_eq(2*<a class="code" href="classtr_1_1SISO.html#8435e16f233e0d70d4335c0695a9ed78" title="Number of reception antennas.">nb_rec_ant</a>*block_duration);
<a name="l00452"></a>00452     itpp::vec interf(2*symbols_block);
<a name="l00453"></a>00453     itpp::vec <a class="code" href="sccc_8m.html#f78ef0e37e7fb8bc7e29d55d92ad055f">temp</a>(2*<a class="code" href="classtr_1_1SISO.html#8435e16f233e0d70d4335c0695a9ed78" title="Number of reception antennas.">nb_rec_ant</a>*block_duration);
<a name="l00454"></a>00454     itpp::vec w(2*<a class="code" href="classtr_1_1SISO.html#8435e16f233e0d70d4335c0695a9ed78" title="Number of reception antennas.">nb_rec_ant</a>*block_duration);<span class="comment">//filter impulse response</span>
<a name="l00455"></a>00455     <span class="keywordtype">double</span> s_tilde;
<a name="l00456"></a>00456     <span class="keywordtype">double</span> mu_res;
<a name="l00457"></a>00457     <span class="keywordtype">double</span> sigma2_res;
<a name="l00458"></a>00458     <span class="keywordtype">double</span> nom,denom;
<a name="l00459"></a>00459     <span class="keywordtype">double</span> tmp;
<a name="l00460"></a>00460     <span class="keyword">register</span> <span class="keywordtype">int</span> ns,q,k,s;
<a name="l00461"></a>00461     <span class="keywordtype">int</span> index;
<a name="l00462"></a>00462 
<a name="l00463"></a>00463     <span class="comment">//correspondence between real and imaginary part of symbols and their binary representations</span>
<a name="l00464"></a>00464     <span class="keywordtype">int</span> select_half;
<a name="l00465"></a>00465     itpp::vec re_part;
<a name="l00466"></a>00466     itpp::bmat re_bin_part;
<a name="l00467"></a>00467     itpp::vec im_part;
<a name="l00468"></a>00468     itpp::bmat im_bin_part;
<a name="l00469"></a>00469     <a class="code" href="classtr_1_1SISO.html#548106d8da90413e8ce9b43755ab0fa8" title="Finds half constellations.">find_half_const</a>(select_half, re_part, re_bin_part, im_part, im_bin_part);
<a name="l00470"></a>00470     <span class="keywordtype">double</span> part_var = 1/(double)(2*<a class="code" href="classtr_1_1SISO.html#38f94774848f716b03774b8087aab581" title="Number of emission antennas.">nb_em_ant</a>);<span class="comment">//real and imaginary part variance</span>
<a name="l00471"></a>00471 
<a name="l00472"></a>00472     extrinsic_data.set_size(<a class="code" href="classtr_1_1SISO.html#6b1847842f0ec2a1f2760a1859d84bfc" title="Number of bits/symbol.">nb_bits_symb</a>*nb_subblocks*symbols_block);
<a name="l00473"></a>00473     <span class="keywordflow">for</span> (ns=0;ns&lt;nb_subblocks;ns++)<span class="comment">//compute block by block</span>
<a name="l00474"></a>00474     {
<a name="l00475"></a>00475         <span class="comment">//mean and variance of real and imaginary parts of emitted symbols</span>
<a name="l00476"></a>00476         Es.zeros();
<a name="l00477"></a>00477         Vs.zeros();
<a name="l00478"></a>00478         <span class="keywordflow">for</span> (q=0;q&lt;symbols_block;q++)
<a name="l00479"></a>00479         {
<a name="l00480"></a>00480             index = q*<a class="code" href="classtr_1_1SISO.html#6b1847842f0ec2a1f2760a1859d84bfc" title="Number of bits/symbol.">nb_bits_symb</a>+ns*symbols_block*<a class="code" href="classtr_1_1SISO.html#6b1847842f0ec2a1f2760a1859d84bfc" title="Number of bits/symbol.">nb_bits_symb</a>;
<a name="l00481"></a>00481             <span class="keywordflow">for</span> (k=0;k&lt;half_const_len;k++)
<a name="l00482"></a>00482             {
<a name="l00483"></a>00483                 <a class="code" href="BICM_8m.html#84b7e4f5537f440cbbf66ab569334e32">Es</a>(2*q) += re_part(k)*itpp::prod(itpp::elem_div(exp(itpp::elem_mult(itpp::to_vec(re_bin_part.get_row(k)), \
<a name="l00484"></a>00484                                                         apriori_data.mid(select_half*half_nb_bits_symb+index, half_nb_bits_symb))), \
<a name="l00485"></a>00485                                                     (1+exp(apriori_data.mid(select_half*half_nb_bits_symb+index, half_nb_bits_symb)))));
<a name="l00486"></a>00486                 <a class="code" href="BICM_8m.html#84b7e4f5537f440cbbf66ab569334e32">Es</a>(1+2*q) += im_part(k)*itpp::prod(itpp::elem_div(exp(itpp::elem_mult(itpp::to_vec(im_bin_part.get_row(k)), \
<a name="l00487"></a>00487                                                       apriori_data.mid((1-select_half)*half_nb_bits_symb+index, half_nb_bits_symb))), \
<a name="l00488"></a>00488                                                       (1+exp(apriori_data.mid((1-select_half)*half_nb_bits_symb+index, half_nb_bits_symb)))));
<a name="l00489"></a>00489                 Vs(2*q) += itpp::sqr(re_part(k))*itpp::prod(itpp::elem_div(exp(itpp::elem_mult(itpp::to_vec(re_bin_part.get_row(k)), \
<a name="l00490"></a>00490                                                 apriori_data.mid(select_half*half_nb_bits_symb+index, half_nb_bits_symb))), \
<a name="l00491"></a>00491                                                 (1+exp(apriori_data.mid(select_half*half_nb_bits_symb+index, half_nb_bits_symb)))));
<a name="l00492"></a>00492                 Vs(1+2*q) += itpp::sqr(im_part(k))*itpp::prod(itpp::elem_div(exp(itpp::elem_mult(itpp::to_vec(im_bin_part.get_row(k)), \
<a name="l00493"></a>00493                                                   apriori_data.mid((1-select_half)*half_nb_bits_symb+index, half_nb_bits_symb))), \
<a name="l00494"></a>00494                                                   (1+exp(apriori_data.mid((1-select_half)*half_nb_bits_symb+index, half_nb_bits_symb)))));
<a name="l00495"></a>00495             }
<a name="l00496"></a>00496             Vs(2*q) -= itpp::sqr(<a class="code" href="BICM_8m.html#84b7e4f5537f440cbbf66ab569334e32">Es</a>(2*q));
<a name="l00497"></a>00497             Vs(1+2*q) -= itpp::sqr(<a class="code" href="BICM_8m.html#84b7e4f5537f440cbbf66ab569334e32">Es</a>(1+2*q));
<a name="l00498"></a>00498         }
<a name="l00499"></a>00499 
<a name="l00500"></a>00500         <span class="comment">//find equivalent channel matrix</span>
<a name="l00501"></a>00501         <a class="code" href="classtr_1_1SISO.html#a4e6c5634642f73694b44a38eb0164a8" title="Finds equivalent channel with real coefficients.">EquivCh</a>(H_eq, <a class="code" href="classtr_1_1SISO.html#dc1f0c3c2ac4579b91b6c859207c1812" title="Complex channel impulse response.">c_impulse_response</a>.get_col(ns));
<a name="l00502"></a>00502         <span class="comment">//compute invariant inverse</span>
<a name="l00503"></a>00503         K = H_eq*diag(Vs)*H_eq.transpose()+<a class="code" href="classtr_1_1SISO.html#0ad35ce8bb26a5d25f5cc56470cf70c4" title="AWGN noise variance.">sigma2</a>*itpp::eye(2*block_duration*<a class="code" href="classtr_1_1SISO.html#8435e16f233e0d70d4335c0695a9ed78" title="Number of reception antennas.">nb_rec_ant</a>);
<a name="l00504"></a>00504         K_inv = itpp::inv(K);
<a name="l00505"></a>00505         <span class="comment">//find equivalent received signal</span>
<a name="l00506"></a>00506         <a class="code" href="classtr_1_1SISO.html#71ccbd3b3b5481096cf9d7c3c16f1343" title="Finds equivalent received signal with real coefficients.">EquivRecSig</a>(x_eq, rec_sig(ns*block_duration,(ns+1)*block_duration-1,0,nb_rec_ant-1));
<a name="l00507"></a>00507         <span class="keywordflow">for</span> (q=0;q&lt;symbols_block;q++)<span class="comment">//symbols/block</span>
<a name="l00508"></a>00508         {
<a name="l00509"></a>00509             <span class="comment">//compute the extrinsic information of coded bits</span>
<a name="l00510"></a>00510             <span class="comment">//real part</span>
<a name="l00511"></a>00511             <span class="comment">//IC + filtering (real and imaginary parts of one symbol)</span>
<a name="l00512"></a>00512             interf = Es;
<a name="l00513"></a>00513             interf(2*q) = 0;<span class="comment">//this is the symbol to recover</span>
<a name="l00514"></a>00514             temp = H_eq.get_col(2*q);
<a name="l00515"></a>00515             w = (part_var*temp.transpose())*(K_inv-itpp::outer_product(K_inv*(((part_var-Vs(2*q))/ \
<a name="l00516"></a>00516                                                     (1+((temp.transpose()*K_inv)*(temp*(part_var-Vs(2*q))))(0)))*temp), K_inv.transpose()*temp));                                                    
<a name="l00517"></a>00517             s_tilde = w*(x_eq-H_eq*interf);
<a name="l00518"></a>00518             mu_res = w*temp;<span class="comment">//mean of the filtered signal</span>
<a name="l00519"></a>00519             index = select_half*half_nb_bits_symb+<a class="code" href="classtr_1_1SISO.html#6b1847842f0ec2a1f2760a1859d84bfc" title="Number of bits/symbol.">nb_bits_symb</a>*q+ns*nb_bits_subblock;
<a name="l00520"></a>00520             <span class="keywordflow">for</span> (k=0;k&lt;half_nb_bits_symb;k++)
<a name="l00521"></a>00521             {
<a name="l00522"></a>00522                 nom = -INFINITY;
<a name="l00523"></a>00523                 denom = -INFINITY;
<a name="l00524"></a>00524                 <span class="keywordflow">for</span> (s=0;s&lt;half_const_len;s++)
<a name="l00525"></a>00525                 {
<a name="l00526"></a>00526                     sigma2_res = ((w.transpose()*(K+itpp::outer_product(temp, temp*(itpp::sqr(re_part(s))-Vs(2*q)))))*w)(0)-itpp::sqr(re_part(s)*mu_res);<span class="comment">//variance of the filtered signal</span>
<a name="l00527"></a>00527                     tmp = -itpp::sqr(s_tilde-mu_res*re_part(s))/(2*sigma2_res)+ \
<a name="l00528"></a>00528                           itpp::to_vec(re_bin_part.get_row(s))*apriori_data.mid(index, half_nb_bits_symb);
<a name="l00529"></a>00529                     <span class="keywordflow">if</span> (re_bin_part(s,k))
<a name="l00530"></a>00530                         nom = std::max(nom, tmp);
<a name="l00531"></a>00531                     <span class="keywordflow">else</span>
<a name="l00532"></a>00532                         denom = std::max(denom, tmp);
<a name="l00533"></a>00533                 }
<a name="l00534"></a>00534                 <a class="code" href="pccc_8m.html#5281907479deebb2221449a1a435e6f9">extrinsic_data</a>(index+k) = (nom-denom)-<a class="code" href="pccc_8m.html#538daf4079e02293176bdde2a829700f">apriori_data</a>(index+k);
<a name="l00535"></a>00535             }
<a name="l00536"></a>00536             <span class="comment">//end real part</span>
<a name="l00537"></a>00537             <span class="comment">//imaginary part</span>
<a name="l00538"></a>00538             <span class="comment">//IC + filtering (real and imaginary parts of one symbol)</span>
<a name="l00539"></a>00539             interf = Es;
<a name="l00540"></a>00540             interf(2*q+1) = 0;<span class="comment">//this is the symbol to recover</span>
<a name="l00541"></a>00541             temp = H_eq.get_col(2*q+1);
<a name="l00542"></a>00542             w = (part_var*temp.transpose())*(K_inv-itpp::outer_product(K_inv*(((part_var-Vs(1+2*q))/ \
<a name="l00543"></a>00543                                                     (1+((temp.transpose()*K_inv)*(temp*(part_var-Vs(1+2*q))))(0)))*temp), K_inv.transpose()*temp));                                                    
<a name="l00544"></a>00544             s_tilde = w*(x_eq-H_eq*interf);
<a name="l00545"></a>00545             mu_res = w*temp;<span class="comment">//mean of the filtered signal</span>
<a name="l00546"></a>00546             index = (1-select_half)*half_nb_bits_symb+<a class="code" href="classtr_1_1SISO.html#6b1847842f0ec2a1f2760a1859d84bfc" title="Number of bits/symbol.">nb_bits_symb</a>*q+ns*nb_bits_subblock;
<a name="l00547"></a>00547             <span class="keywordflow">for</span> (k=0;k&lt;half_nb_bits_symb;k++)
<a name="l00548"></a>00548             {
<a name="l00549"></a>00549                 nom = -INFINITY;
<a name="l00550"></a>00550                 denom = -INFINITY;
<a name="l00551"></a>00551                 <span class="keywordflow">for</span> (s=0;s&lt;half_const_len;s++)
<a name="l00552"></a>00552                 {
<a name="l00553"></a>00553                     sigma2_res = ((w.transpose()*(K+itpp::outer_product(temp, temp*(itpp::sqr(im_part(s))-Vs(1+2*q)))))*w)(0)-itpp::sqr(im_part(s)*mu_res);<span class="comment">//variance of the filtered signal</span>
<a name="l00554"></a>00554                     tmp = -itpp::sqr(s_tilde-mu_res*im_part(s))/(2*sigma2_res)+ \
<a name="l00555"></a>00555                           itpp::to_vec(im_bin_part.get_row(s))*apriori_data.mid(index, half_nb_bits_symb);
<a name="l00556"></a>00556                     <span class="keywordflow">if</span> (im_bin_part(s,k))
<a name="l00557"></a>00557                         nom = std::max(nom, tmp);
<a name="l00558"></a>00558                     <span class="keywordflow">else</span>
<a name="l00559"></a>00559                         denom = std::max(denom, tmp);
<a name="l00560"></a>00560                 }
<a name="l00561"></a>00561                 <a class="code" href="pccc_8m.html#5281907479deebb2221449a1a435e6f9">extrinsic_data</a>(index+k) = (nom-denom)-<a class="code" href="pccc_8m.html#538daf4079e02293176bdde2a829700f">apriori_data</a>(index+k);
<a name="l00562"></a>00562             }
<a name="l00563"></a>00563             <span class="comment">//end imaginary part</span>
<a name="l00564"></a>00564         }<span class="comment">//symbols/block</span>
<a name="l00565"></a>00565     }<span class="comment">//block by block</span>
<a name="l00566"></a>00566 }
<a name="l00567"></a>00567 
<a name="l00568"></a><a class="code" href="classtr_1_1SISO.html#51b8ffbc2c06b0ae539eac1ff51e072c">00568</a> <span class="keywordtype">void</span> <a class="code" href="classtr_1_1SISO.html#51b8ffbc2c06b0ae539eac1ff51e072c" title="SISO::demapper using ZF Parallel Interference Canceller (PIC).">SISO::zfPIC</a>(itpp::vec &amp;<a class="code" href="pccc_8m.html#5281907479deebb2221449a1a435e6f9">extrinsic_data</a>, <span class="keyword">const</span> itpp::cmat &amp;rec_sig, <span class="keyword">const</span> itpp::vec &amp;<a class="code" href="pccc_8m.html#538daf4079e02293176bdde2a829700f">apriori_data</a>)
<a name="l00569"></a>00569 <span class="comment">//ZF Parallel Interference Canceller</span>
<a name="l00570"></a>00570 {
<a name="l00571"></a>00571     <span class="comment">//general parameters</span>
<a name="l00572"></a>00572     <span class="keywordtype">int</span> nb_subblocks = rec_sig.rows()/<a class="code" href="classtr_1_1SISO.html#5f08c69d75d1ed4d3152f5d9d1e45836" title="ST code block duration.">block_duration</a>;<span class="comment">//number of subblocks</span>
<a name="l00573"></a>00573     <span class="keywordtype">int</span> half_nb_bits_symb = <a class="code" href="classtr_1_1SISO.html#6b1847842f0ec2a1f2760a1859d84bfc" title="Number of bits/symbol.">nb_bits_symb</a>/2;
<a name="l00574"></a>00574     <span class="keywordtype">int</span> half_const_len = itpp::pow2i(half_nb_bits_symb);
<a name="l00575"></a>00575     <span class="keywordtype">int</span> nb_bits_subblock = <a class="code" href="classtr_1_1SISO.html#6b1847842f0ec2a1f2760a1859d84bfc" title="Number of bits/symbol.">nb_bits_symb</a>*<a class="code" href="classtr_1_1SISO.html#6f3b090b54b8bf8bda6114ee2d679b3b" title="Number of symbols/block.">symbols_block</a>;<span class="comment">//number of coded bits in an ST block</span>
<a name="l00576"></a>00576     itpp::vec <a class="code" href="BICM_8m.html#84b7e4f5537f440cbbf66ab569334e32">Es</a>(2*symbols_block);
<a name="l00577"></a>00577     itpp::vec Vs(2*symbols_block);
<a name="l00578"></a>00578     itpp::mat H_eq(2*<a class="code" href="classtr_1_1SISO.html#8435e16f233e0d70d4335c0695a9ed78" title="Number of reception antennas.">nb_rec_ant</a>*<a class="code" href="classtr_1_1SISO.html#5f08c69d75d1ed4d3152f5d9d1e45836" title="ST code block duration.">block_duration</a>,2*symbols_block);
<a name="l00579"></a>00579     itpp::mat K(2*<a class="code" href="classtr_1_1SISO.html#8435e16f233e0d70d4335c0695a9ed78" title="Number of reception antennas.">nb_rec_ant</a>*block_duration,2*<a class="code" href="classtr_1_1SISO.html#8435e16f233e0d70d4335c0695a9ed78" title="Number of reception antennas.">nb_rec_ant</a>*block_duration);
<a name="l00580"></a>00580     itpp::vec x_eq(2*<a class="code" href="classtr_1_1SISO.html#8435e16f233e0d70d4335c0695a9ed78" title="Number of reception antennas.">nb_rec_ant</a>*block_duration);
<a name="l00581"></a>00581     itpp::vec interf(2*symbols_block);
<a name="l00582"></a>00582     itpp::vec <a class="code" href="sccc_8m.html#f78ef0e37e7fb8bc7e29d55d92ad055f">temp</a>(2*<a class="code" href="classtr_1_1SISO.html#8435e16f233e0d70d4335c0695a9ed78" title="Number of reception antennas.">nb_rec_ant</a>*block_duration);
<a name="l00583"></a>00583     itpp::vec w(2*<a class="code" href="classtr_1_1SISO.html#8435e16f233e0d70d4335c0695a9ed78" title="Number of reception antennas.">nb_rec_ant</a>*block_duration);<span class="comment">//filter impulse response</span>
<a name="l00584"></a>00584     <span class="keywordtype">double</span> s_tilde;
<a name="l00585"></a>00585     <span class="keywordtype">double</span> mu_res;
<a name="l00586"></a>00586     <span class="keywordtype">double</span> sigma2_res;
<a name="l00587"></a>00587     <span class="keywordtype">double</span> nom,denom;
<a name="l00588"></a>00588     <span class="keywordtype">double</span> tmp;
<a name="l00589"></a>00589     <span class="keyword">register</span> <span class="keywordtype">int</span> ns,q,k,s;
<a name="l00590"></a>00590     <span class="keywordtype">int</span> index;
<a name="l00591"></a>00591 
<a name="l00592"></a>00592     <span class="comment">//correspondence between real and imaginary part of symbols and their binary representations</span>
<a name="l00593"></a>00593     <span class="keywordtype">int</span> select_half;
<a name="l00594"></a>00594     itpp::vec re_part;
<a name="l00595"></a>00595     itpp::bmat re_bin_part;
<a name="l00596"></a>00596     itpp::vec im_part;
<a name="l00597"></a>00597     itpp::bmat im_bin_part;
<a name="l00598"></a>00598     <a class="code" href="classtr_1_1SISO.html#548106d8da90413e8ce9b43755ab0fa8" title="Finds half constellations.">find_half_const</a>(select_half, re_part, re_bin_part, im_part, im_bin_part);
<a name="l00599"></a>00599 
<a name="l00600"></a>00600     extrinsic_data.set_size(<a class="code" href="classtr_1_1SISO.html#6b1847842f0ec2a1f2760a1859d84bfc" title="Number of bits/symbol.">nb_bits_symb</a>*nb_subblocks*symbols_block);
<a name="l00601"></a>00601     <span class="keywordflow">for</span> (ns=0;ns&lt;nb_subblocks;ns++)<span class="comment">//compute block by block</span>
<a name="l00602"></a>00602     {
<a name="l00603"></a>00603         <span class="comment">//mean and variance of real and imaginary parts of emitted symbols</span>
<a name="l00604"></a>00604         Es.zeros();
<a name="l00605"></a>00605         Vs.zeros();
<a name="l00606"></a>00606         <span class="keywordflow">for</span> (q=0;q&lt;symbols_block;q++)
<a name="l00607"></a>00607         {
<a name="l00608"></a>00608             index = q*<a class="code" href="classtr_1_1SISO.html#6b1847842f0ec2a1f2760a1859d84bfc" title="Number of bits/symbol.">nb_bits_symb</a>+ns*symbols_block*<a class="code" href="classtr_1_1SISO.html#6b1847842f0ec2a1f2760a1859d84bfc" title="Number of bits/symbol.">nb_bits_symb</a>;
<a name="l00609"></a>00609             <span class="keywordflow">for</span> (k=0;k&lt;half_const_len;k++)
<a name="l00610"></a>00610             {
<a name="l00611"></a>00611                 <a class="code" href="BICM_8m.html#84b7e4f5537f440cbbf66ab569334e32">Es</a>(2*q) += re_part(k)*itpp::prod(itpp::elem_div(exp(itpp::elem_mult(itpp::to_vec(re_bin_part.get_row(k)), \
<a name="l00612"></a>00612                                                         apriori_data.mid(select_half*half_nb_bits_symb+index, half_nb_bits_symb))), \
<a name="l00613"></a>00613                                                     (1+exp(apriori_data.mid(select_half*half_nb_bits_symb+index, half_nb_bits_symb)))));
<a name="l00614"></a>00614                 <a class="code" href="BICM_8m.html#84b7e4f5537f440cbbf66ab569334e32">Es</a>(1+2*q) += im_part(k)*itpp::prod(itpp::elem_div(exp(itpp::elem_mult(itpp::to_vec(im_bin_part.get_row(k)), \
<a name="l00615"></a>00615                                                       apriori_data.mid((1-select_half)*half_nb_bits_symb+index, half_nb_bits_symb))), \
<a name="l00616"></a>00616                                                       (1+exp(apriori_data.mid((1-select_half)*half_nb_bits_symb+index, half_nb_bits_symb)))));
<a name="l00617"></a>00617                 Vs(2*q) += itpp::sqr(re_part(k))*itpp::prod(itpp::elem_div(exp(itpp::elem_mult(itpp::to_vec(re_bin_part.get_row(k)), \
<a name="l00618"></a>00618                                                 apriori_data.mid(select_half*half_nb_bits_symb+index, half_nb_bits_symb))), \
<a name="l00619"></a>00619                                                 (1+exp(apriori_data.mid(select_half*half_nb_bits_symb+index, half_nb_bits_symb)))));
<a name="l00620"></a>00620                 Vs(1+2*q) += itpp::sqr(im_part(k))*itpp::prod(itpp::elem_div(exp(itpp::elem_mult(to_vec(im_bin_part.get_row(k)), \
<a name="l00621"></a>00621                                                   apriori_data.mid((1-select_half)*half_nb_bits_symb+index, half_nb_bits_symb))), \
<a name="l00622"></a>00622                                                   (1+exp(apriori_data.mid((1-select_half)*half_nb_bits_symb+index, half_nb_bits_symb)))));
<a name="l00623"></a>00623             }
<a name="l00624"></a>00624             Vs(2*q) -= itpp::sqr(<a class="code" href="BICM_8m.html#84b7e4f5537f440cbbf66ab569334e32">Es</a>(2*q));
<a name="l00625"></a>00625             Vs(1+2*q) -= itpp::sqr(<a class="code" href="BICM_8m.html#84b7e4f5537f440cbbf66ab569334e32">Es</a>(1+2*q));
<a name="l00626"></a>00626         }
<a name="l00627"></a>00627 
<a name="l00628"></a>00628         <span class="comment">//find equivalent channel matrix</span>
<a name="l00629"></a>00629         <a class="code" href="classtr_1_1SISO.html#a4e6c5634642f73694b44a38eb0164a8" title="Finds equivalent channel with real coefficients.">EquivCh</a>(H_eq, <a class="code" href="classtr_1_1SISO.html#dc1f0c3c2ac4579b91b6c859207c1812" title="Complex channel impulse response.">c_impulse_response</a>.get_col(ns));
<a name="l00630"></a>00630         <span class="comment">//compute invariant inverse</span>
<a name="l00631"></a>00631         K = H_eq*itpp::diag(Vs)*H_eq.transpose()+<a class="code" href="classtr_1_1SISO.html#0ad35ce8bb26a5d25f5cc56470cf70c4" title="AWGN noise variance.">sigma2</a>*itpp::eye(2*block_duration*<a class="code" href="classtr_1_1SISO.html#8435e16f233e0d70d4335c0695a9ed78" title="Number of reception antennas.">nb_rec_ant</a>);
<a name="l00632"></a>00632         <span class="comment">//find equivalent received signal</span>
<a name="l00633"></a>00633         <a class="code" href="classtr_1_1SISO.html#71ccbd3b3b5481096cf9d7c3c16f1343" title="Finds equivalent received signal with real coefficients.">EquivRecSig</a>(x_eq, rec_sig(ns*block_duration,(ns+1)*block_duration-1,0,nb_rec_ant-1));
<a name="l00634"></a>00634         <span class="keywordflow">for</span> (q=0;q&lt;symbols_block;q++)<span class="comment">//symbols/block</span>
<a name="l00635"></a>00635         {
<a name="l00636"></a>00636             <span class="comment">//compute the extrinsic information of coded bits</span>
<a name="l00637"></a>00637             <span class="comment">//real part</span>
<a name="l00638"></a>00638             <span class="comment">//IC + filtering (real and imaginary parts of one symbol)</span>
<a name="l00639"></a>00639             interf = Es;
<a name="l00640"></a>00640             interf(2*q) = 0;<span class="comment">//this is the symbol to recover</span>
<a name="l00641"></a>00641             temp = H_eq.get_col(2*q);
<a name="l00642"></a>00642             w = temp/(temp*temp);<span class="comment">//filter impulse response</span>
<a name="l00643"></a>00643             s_tilde = w*(x_eq-H_eq*interf);
<a name="l00644"></a>00644             mu_res = w*temp;<span class="comment">//mean of the filtered signal</span>
<a name="l00645"></a>00645             index = select_half*half_nb_bits_symb+<a class="code" href="classtr_1_1SISO.html#6b1847842f0ec2a1f2760a1859d84bfc" title="Number of bits/symbol.">nb_bits_symb</a>*q+ns*nb_bits_subblock;
<a name="l00646"></a>00646             <span class="keywordflow">for</span> (k=0;k&lt;half_nb_bits_symb;k++)
<a name="l00647"></a>00647             {
<a name="l00648"></a>00648                 nom = -INFINITY;
<a name="l00649"></a>00649                 denom = -INFINITY;
<a name="l00650"></a>00650                 <span class="keywordflow">for</span> (s=0;s&lt;half_const_len;s++)
<a name="l00651"></a>00651                 {
<a name="l00652"></a>00652                     sigma2_res = ((w.transpose()*(K+itpp::outer_product(temp, temp*(itpp::sqr(re_part(s))-Vs(2*q)))))*w)(0)-itpp::sqr(re_part(s)*mu_res);
<a name="l00653"></a>00653                     tmp = -itpp::sqr(s_tilde-mu_res*re_part(s))/(2*sigma2_res)+ \
<a name="l00654"></a>00654                           itpp::to_vec(re_bin_part.get_row(s))*apriori_data.mid(index, half_nb_bits_symb);
<a name="l00655"></a>00655                     <span class="keywordflow">if</span> (re_bin_part(s,k))
<a name="l00656"></a>00656                         nom = std::max(nom, tmp);
<a name="l00657"></a>00657                     <span class="keywordflow">else</span>
<a name="l00658"></a>00658                         denom = std::max(denom, tmp);
<a name="l00659"></a>00659                 }
<a name="l00660"></a>00660                 <a class="code" href="pccc_8m.html#5281907479deebb2221449a1a435e6f9">extrinsic_data</a>(index+k) = (nom-denom)-<a class="code" href="pccc_8m.html#538daf4079e02293176bdde2a829700f">apriori_data</a>(index+k);
<a name="l00661"></a>00661             }
<a name="l00662"></a>00662             <span class="comment">//end real part</span>
<a name="l00663"></a>00663             <span class="comment">//imaginary part</span>
<a name="l00664"></a>00664             <span class="comment">//IC + filtering (real and imaginary parts of one symbol)</span>
<a name="l00665"></a>00665             interf = Es;
<a name="l00666"></a>00666             interf(2*q+1) = 0;<span class="comment">//this is the symbol to recover</span>
<a name="l00667"></a>00667             temp = H_eq.get_col(2*q+1);
<a name="l00668"></a>00668             w = temp/(temp*temp);<span class="comment">//filter impulse response</span>
<a name="l00669"></a>00669             s_tilde = w*(x_eq-H_eq*interf);
<a name="l00670"></a>00670             mu_res = w*temp;<span class="comment">//mean of the filtered signal</span>
<a name="l00671"></a>00671             index = (1-select_half)*half_nb_bits_symb+<a class="code" href="classtr_1_1SISO.html#6b1847842f0ec2a1f2760a1859d84bfc" title="Number of bits/symbol.">nb_bits_symb</a>*q+ns*nb_bits_subblock;
<a name="l00672"></a>00672             <span class="keywordflow">for</span> (k=0;k&lt;half_nb_bits_symb;k++)
<a name="l00673"></a>00673             {
<a name="l00674"></a>00674                 nom = -INFINITY;
<a name="l00675"></a>00675                 denom = -INFINITY;
<a name="l00676"></a>00676                 <span class="keywordflow">for</span> (s=0;s&lt;half_const_len;s++)
<a name="l00677"></a>00677                 {
<a name="l00678"></a>00678                     sigma2_res = ((w.transpose()*(K+itpp::outer_product(temp, temp*(itpp::sqr(im_part(s))-Vs(1+2*q)))))*w)(0)-itpp::sqr(im_part(s)*mu_res);
<a name="l00679"></a>00679                     tmp = -itpp::sqr(s_tilde-mu_res*im_part(s))/(2*sigma2_res)+ \
<a name="l00680"></a>00680                           itpp::to_vec(im_bin_part.get_row(s))*apriori_data.mid(index, half_nb_bits_symb);
<a name="l00681"></a>00681                     <span class="keywordflow">if</span> (im_bin_part(s,k))
<a name="l00682"></a>00682                         nom = std::max(nom, tmp);
<a name="l00683"></a>00683                     <span class="keywordflow">else</span>
<a name="l00684"></a>00684                         denom = std::max(denom, tmp);
<a name="l00685"></a>00685                 }
<a name="l00686"></a>00686                 <a class="code" href="pccc_8m.html#5281907479deebb2221449a1a435e6f9">extrinsic_data</a>(index+k) = (nom-denom)-<a class="code" href="pccc_8m.html#538daf4079e02293176bdde2a829700f">apriori_data</a>(index+k);
<a name="l00687"></a>00687             }
<a name="l00688"></a>00688             <span class="comment">//end imaginary part</span>
<a name="l00689"></a>00689         }<span class="comment">//symbols/block</span>
<a name="l00690"></a>00690     }<span class="comment">//block by block</span>
<a name="l00691"></a>00691 }
<a name="l00692"></a>00692 
<a name="l00693"></a><a class="code" href="classtr_1_1SISO.html#61e523521a4dc16da46ede0c07ca274f">00693</a> <span class="keywordtype">void</span> <a class="code" href="classtr_1_1SISO.html#61e523521a4dc16da46ede0c07ca274f" title="SISO::demapper using maxlogMAP algorithm and matched filter receiver for Alamouti...">SISO::Alamouti_maxlogMAP</a>(itpp::vec &amp;<a class="code" href="pccc_8m.html#5281907479deebb2221449a1a435e6f9">extrinsic_data</a>, <span class="keyword">const</span> itpp::cmat &amp;rec_sig, <span class="keyword">const</span> itpp::vec &amp;<a class="code" href="pccc_8m.html#538daf4079e02293176bdde2a829700f">apriori_data</a>)
<a name="l00694"></a>00694 <span class="comment">//maxlogMAP algorithm for Alamouti ST code</span>
<a name="l00695"></a>00695 {
<a name="l00696"></a>00696     <span class="comment">//matched filter</span>
<a name="l00697"></a>00697     <span class="keywordtype">int</span> int_len = apriori_data.length();<span class="comment">//interleaver length</span>
<a name="l00698"></a>00698     <span class="keywordtype">int</span> <a class="code" href="BICM_8m.html#d40b1b0249989a08d8a1a510635905d7">nb_symb</a> = (int)(int_len/<a class="code" href="classtr_1_1SISO.html#6b1847842f0ec2a1f2760a1859d84bfc" title="Number of bits/symbol.">nb_bits_symb</a>);<span class="comment">//number of symbols/block</span>
<a name="l00699"></a>00699     itpp::cvec comb_sig(nb_symb);
<a name="l00700"></a>00700     comb_sig.zeros();
<a name="l00701"></a>00701     itpp::cmat conj_H = itpp::conj(<a class="code" href="classtr_1_1SISO.html#dc1f0c3c2ac4579b91b6c859207c1812" title="Complex channel impulse response.">c_impulse_response</a>);
<a name="l00702"></a>00702     itpp::cmat conj_X = itpp::conj(rec_sig);
<a name="l00703"></a>00703     <span class="keyword">register</span> <span class="keywordtype">int</span> nr,<a class="code" href="pccc_8m.html#b16835ef8374501899a0b3db115584fc">n</a>,cs;
<a name="l00704"></a>00704     <span class="keywordflow">for</span> (nr=0;nr&lt;<a class="code" href="classtr_1_1SISO.html#8435e16f233e0d70d4335c0695a9ed78" title="Number of reception antennas.">nb_rec_ant</a>;nr++)
<a name="l00705"></a>00705     {
<a name="l00706"></a>00706         <span class="keywordflow">for</span> (n=0;n&lt;(nb_symb/2);n++)
<a name="l00707"></a>00707         {
<a name="l00708"></a>00708             comb_sig(2*n) += (conj_H(2*nr,n)*rec_sig(2*n,nr)+<a class="code" href="classtr_1_1SISO.html#dc1f0c3c2ac4579b91b6c859207c1812" title="Complex channel impulse response.">c_impulse_response</a>(1+2*nr,n)*conj_X(1+2*n,nr));
<a name="l00709"></a>00709             comb_sig(1+2*n) += (conj_H(1+2*nr,n)*rec_sig(2*n,nr)-<a class="code" href="classtr_1_1SISO.html#dc1f0c3c2ac4579b91b6c859207c1812" title="Complex channel impulse response.">c_impulse_response</a>(2*nr,n)*conj_X(1+2*n,nr));
<a name="l00710"></a>00710         }
<a name="l00711"></a>00711     }
<a name="l00712"></a>00712 
<a name="l00713"></a>00713     <span class="comment">//extrinsic information of coded bits</span>
<a name="l00714"></a>00714     <span class="keywordtype">int</span> const_size = itpp::pow2i(<a class="code" href="classtr_1_1SISO.html#6b1847842f0ec2a1f2760a1859d84bfc" title="Number of bits/symbol.">nb_bits_symb</a>);<span class="comment">//constellation size</span>
<a name="l00715"></a>00715     <span class="keywordtype">double</span> buffer;
<a name="l00716"></a>00716     <span class="keywordtype">double</span> nom,denom;
<a name="l00717"></a>00717     <span class="keywordtype">double</span> <a class="code" href="sccc_8m.html#f78ef0e37e7fb8bc7e29d55d92ad055f">temp</a>;
<a name="l00718"></a>00718     <span class="keywordtype">int</span> index;
<a name="l00719"></a>00719     extrinsic_data.set_size(<a class="code" href="classtr_1_1SISO.html#6b1847842f0ec2a1f2760a1859d84bfc" title="Number of bits/symbol.">nb_bits_symb</a>*nb_symb);
<a name="l00720"></a>00720     <span class="keywordflow">for</span> (n=0;n&lt;nb_symb;n++)
<a name="l00721"></a>00721     {
<a name="l00722"></a>00722         buffer = itpp::sum_sqr(itpp::abs(<a class="code" href="classtr_1_1SISO.html#dc1f0c3c2ac4579b91b6c859207c1812" title="Complex channel impulse response.">c_impulse_response</a>.get_col(n/2)));
<a name="l00723"></a>00723         <span class="keywordflow">for</span> (nr=0;nr&lt;<a class="code" href="classtr_1_1SISO.html#6b1847842f0ec2a1f2760a1859d84bfc" title="Number of bits/symbol.">nb_bits_symb</a>;nr++)
<a name="l00724"></a>00724         {
<a name="l00725"></a>00725             nom = -INFINITY;
<a name="l00726"></a>00726             denom = -INFINITY;
<a name="l00727"></a>00727             <span class="keywordflow">for</span> (cs=0;cs&lt;const_size;cs++)
<a name="l00728"></a>00728             {
<a name="l00729"></a>00729                 temp = -itpp::sqr(comb_sig(n)-buffer*<a class="code" href="classtr_1_1SISO.html#66228208aac18d4a2642de5a95ee52ff" title="Complex constellation.">constellation</a>(cs))/(2*buffer*<a class="code" href="classtr_1_1SISO.html#0ad35ce8bb26a5d25f5cc56470cf70c4" title="AWGN noise variance.">sigma2</a>)+ \
<a name="l00730"></a>00730                        itpp::to_vec(<a class="code" href="classtr_1_1SISO.html#8af248fca5002121beca5a4a5673ba12" title="Binary constellation.">bin_constellation</a>.get_row(cs))*apriori_data.mid(n*nb_bits_symb, nb_bits_symb);
<a name="l00731"></a>00731                 <span class="keywordflow">if</span> (<a class="code" href="classtr_1_1SISO.html#8af248fca5002121beca5a4a5673ba12" title="Binary constellation.">bin_constellation</a>(cs,nr))
<a name="l00732"></a>00732                     nom = std::max(nom, temp);
<a name="l00733"></a>00733                 <span class="keywordflow">else</span>
<a name="l00734"></a>00734                     denom = std::max(denom, temp);
<a name="l00735"></a>00735             }
<a name="l00736"></a>00736             index = n*nb_bits_symb+nr;
<a name="l00737"></a>00737             <a class="code" href="pccc_8m.html#5281907479deebb2221449a1a435e6f9">extrinsic_data</a>(index) = (nom-denom)-<a class="code" href="pccc_8m.html#538daf4079e02293176bdde2a829700f">apriori_data</a>(index);<span class="comment">//extrinsic information</span>
<a name="l00738"></a>00738         }
<a name="l00739"></a>00739     }
<a name="l00740"></a>00740 }
<a name="l00741"></a>00741 
<a name="l00742"></a><a class="code" href="classtr_1_1SISO.html#2c2c0384b6d35db4ae6f50adf5f2c851">00742</a> <span class="keywordtype">void</span> <a class="code" href="classtr_1_1SISO.html#2c2c0384b6d35db4ae6f50adf5f2c851" title="SISO::demapper using logMAP algorithm for complex modulators.">SISO::demodulator_logMAP</a>(itpp::vec &amp;<a class="code" href="pccc_8m.html#5281907479deebb2221449a1a435e6f9">extrinsic_data</a>, <span class="keyword">const</span> itpp::cvec &amp;rec_sig, <span class="keyword">const</span> itpp::vec &amp;<a class="code" href="pccc_8m.html#538daf4079e02293176bdde2a829700f">apriori_data</a>)
<a name="l00744"></a>00744 {
<a name="l00745"></a>00745     <span class="keywordtype">int</span> <a class="code" href="BICM_8m.html#d40b1b0249989a08d8a1a510635905d7">nb_symb</a> = rec_sig.length();
<a name="l00746"></a>00746     <span class="keywordtype">int</span> const_size = itpp::pow2i(<a class="code" href="classtr_1_1SISO.html#6b1847842f0ec2a1f2760a1859d84bfc" title="Number of bits/symbol.">nb_bits_symb</a>);
<a name="l00747"></a>00747     <span class="keywordtype">double</span> nom,denom,<a class="code" href="sccc_8m.html#f78ef0e37e7fb8bc7e29d55d92ad055f">temp</a>;
<a name="l00748"></a>00748     <span class="keyword">register</span> <span class="keywordtype">int</span> k,i,cs;
<a name="l00749"></a>00749     <span class="keywordtype">int</span> index;
<a name="l00750"></a>00750     extrinsic_data.set_size(<a class="code" href="classtr_1_1SISO.html#6b1847842f0ec2a1f2760a1859d84bfc" title="Number of bits/symbol.">nb_bits_symb</a>*nb_symb);
<a name="l00751"></a>00751     <span class="keywordflow">for</span>(k=0;k&lt;nb_symb;k++)
<a name="l00752"></a>00752     {
<a name="l00753"></a>00753         <span class="keywordflow">for</span>(i=0;i&lt;<a class="code" href="classtr_1_1SISO.html#6b1847842f0ec2a1f2760a1859d84bfc" title="Number of bits/symbol.">nb_bits_symb</a>;i++)
<a name="l00754"></a>00754         {
<a name="l00755"></a>00755             nom = 0;
<a name="l00756"></a>00756             denom = 0;
<a name="l00757"></a>00757             <span class="keywordflow">for</span>(cs=0;cs&lt;const_size;cs++)
<a name="l00758"></a>00758             {
<a name="l00759"></a>00759                 temp = -itpp::sqr(rec_sig(k)-<a class="code" href="classtr_1_1SISO.html#dc1f0c3c2ac4579b91b6c859207c1812" title="Complex channel impulse response.">c_impulse_response</a>(0,k)*<a class="code" href="classtr_1_1SISO.html#66228208aac18d4a2642de5a95ee52ff" title="Complex constellation.">constellation</a>(cs))/(2*<a class="code" href="classtr_1_1SISO.html#0ad35ce8bb26a5d25f5cc56470cf70c4" title="AWGN noise variance.">sigma2</a>)+\
<a name="l00760"></a>00760                     itpp::to_vec(<a class="code" href="classtr_1_1SISO.html#8af248fca5002121beca5a4a5673ba12" title="Binary constellation.">bin_constellation</a>.get_row(cs))*apriori_data.mid(k*nb_bits_symb, nb_bits_symb);
<a name="l00761"></a>00761                 <span class="keywordflow">if</span>(<a class="code" href="classtr_1_1SISO.html#8af248fca5002121beca5a4a5673ba12" title="Binary constellation.">bin_constellation</a>(cs,i))
<a name="l00762"></a>00762                     nom += exp(temp);
<a name="l00763"></a>00763                 <span class="keywordflow">else</span>
<a name="l00764"></a>00764                     denom += exp(temp);
<a name="l00765"></a>00765             }
<a name="l00766"></a>00766             index = k*nb_bits_symb+i;
<a name="l00767"></a>00767             <a class="code" href="pccc_8m.html#5281907479deebb2221449a1a435e6f9">extrinsic_data</a>(index) = log(nom/denom)-<a class="code" href="pccc_8m.html#538daf4079e02293176bdde2a829700f">apriori_data</a>(index);<span class="comment">//extrinsic information</span>
<a name="l00768"></a>00768         }
<a name="l00769"></a>00769     }
<a name="l00770"></a>00770 }
<a name="l00771"></a>00771 
<a name="l00772"></a><a class="code" href="classtr_1_1SISO.html#5598258e26daac7d5e977eb5c53557d8">00772</a> <span class="keywordtype">void</span> <a class="code" href="classtr_1_1SISO.html#5598258e26daac7d5e977eb5c53557d8" title="SISO::demapper using maxlogMAP algorithm for complex modulators.">SISO::demodulator_maxlogMAP</a>(itpp::vec &amp;<a class="code" href="pccc_8m.html#5281907479deebb2221449a1a435e6f9">extrinsic_data</a>, <span class="keyword">const</span> itpp::cvec &amp;rec_sig, <span class="keyword">const</span> itpp::vec &amp;<a class="code" href="pccc_8m.html#538daf4079e02293176bdde2a829700f">apriori_data</a>)
<a name="l00774"></a>00774 {
<a name="l00775"></a>00775     <span class="keywordtype">int</span> <a class="code" href="BICM_8m.html#d40b1b0249989a08d8a1a510635905d7">nb_symb</a> = rec_sig.length();
<a name="l00776"></a>00776     <span class="keywordtype">int</span> const_size = itpp::pow2i(<a class="code" href="classtr_1_1SISO.html#6b1847842f0ec2a1f2760a1859d84bfc" title="Number of bits/symbol.">nb_bits_symb</a>);
<a name="l00777"></a>00777     <span class="keywordtype">double</span> nom,denom,<a class="code" href="sccc_8m.html#f78ef0e37e7fb8bc7e29d55d92ad055f">temp</a>;
<a name="l00778"></a>00778     <span class="keyword">register</span> <span class="keywordtype">int</span> k,i,cs;
<a name="l00779"></a>00779     <span class="keywordtype">int</span> index;
<a name="l00780"></a>00780     extrinsic_data.set_size(<a class="code" href="classtr_1_1SISO.html#6b1847842f0ec2a1f2760a1859d84bfc" title="Number of bits/symbol.">nb_bits_symb</a>*nb_symb);
<a name="l00781"></a>00781     <span class="keywordflow">for</span>(k=0;k&lt;nb_symb;k++)
<a name="l00782"></a>00782     {
<a name="l00783"></a>00783         <span class="keywordflow">for</span>(i=0;i&lt;<a class="code" href="classtr_1_1SISO.html#6b1847842f0ec2a1f2760a1859d84bfc" title="Number of bits/symbol.">nb_bits_symb</a>;i++)
<a name="l00784"></a>00784         {
<a name="l00785"></a>00785             nom = -INFINITY;
<a name="l00786"></a>00786             denom = -INFINITY;
<a name="l00787"></a>00787             <span class="keywordflow">for</span>(cs=0;cs&lt;const_size;cs++)
<a name="l00788"></a>00788             {
<a name="l00789"></a>00789                 temp = -itpp::sqr(rec_sig(k)-<a class="code" href="classtr_1_1SISO.html#dc1f0c3c2ac4579b91b6c859207c1812" title="Complex channel impulse response.">c_impulse_response</a>(0,k)*<a class="code" href="classtr_1_1SISO.html#66228208aac18d4a2642de5a95ee52ff" title="Complex constellation.">constellation</a>(cs))/(2*<a class="code" href="classtr_1_1SISO.html#0ad35ce8bb26a5d25f5cc56470cf70c4" title="AWGN noise variance.">sigma2</a>)+\
<a name="l00790"></a>00790                     itpp::to_vec(<a class="code" href="classtr_1_1SISO.html#8af248fca5002121beca5a4a5673ba12" title="Binary constellation.">bin_constellation</a>.get_row(cs))*apriori_data.mid(k*nb_bits_symb, nb_bits_symb);
<a name="l00791"></a>00791                 <span class="keywordflow">if</span>(<a class="code" href="classtr_1_1SISO.html#8af248fca5002121beca5a4a5673ba12" title="Binary constellation.">bin_constellation</a>(cs,i))
<a name="l00792"></a>00792                     nom = std::max(nom, temp);
<a name="l00793"></a>00793                 <span class="keywordflow">else</span>
<a name="l00794"></a>00794                     denom = std::max(denom, temp);
<a name="l00795"></a>00795             }
<a name="l00796"></a>00796             index = k*nb_bits_symb+i;
<a name="l00797"></a>00797             <a class="code" href="pccc_8m.html#5281907479deebb2221449a1a435e6f9">extrinsic_data</a>(index) = (nom-denom)-<a class="code" href="pccc_8m.html#538daf4079e02293176bdde2a829700f">apriori_data</a>(index);<span class="comment">//extrinsic information</span>
<a name="l00798"></a>00798         }
<a name="l00799"></a>00799     }
<a name="l00800"></a>00800 }
<a name="l00801"></a>00801 }<span class="comment">//end namespace tr</span>
</pre></div></div>
<hr size="1"><address style="text-align: right;"><small><a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> </small></address>
</body>
</html>
